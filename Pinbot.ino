// Rules for the Pinbot pinball machine

bool PB_OpenVisorFlag = false;                        // visor is being opened if true
bool PB_CloseVisorFlag = false;                       // visor is being closed if true
bool PB_DropWait = false;                             // ignore drop target switches when true
bool PB_DropRamp = false;                             // ramp needs to be dropped when possible
bool PB_EnergyActive = false;                         // score energy active?
bool PB_SkillShot = false;                            // is the skill shot active?
bool PB_IgnoreLock = false;                           // ignore the lock switches to cope with switch bouncing
bool PB_SpecialLit = false;                           // is the special lit?
byte PB_BallSave = 0;                                 // prevent immediate outlane drains 0=inactive 1=active 2=triggered
byte PB_ChestMode = 0;                                // current status of the chest and visor
uint16_t PB_SolarValue = 100;                         // current solar value / 1000
byte PB_SolarValueTimer = 0;                          // number of the timer for the solar value shot
byte PB_ChestLightsTimer = 0;                         // number of the timer controlling the chest lamp sequencing
byte PB_LampSweepActive = 0;                          // determines whether the backbox lamp sweep is active
byte PB_SkillMultiplier = 0;                          // Multiplier for the skill shot value
byte PB_DropBlinkLamp = 0;                            // number of the lamp currently blinking
byte PB_LitChestLamps[4];                             // amount of lit chest lamps for each player
byte PB_ChestLamp[4][5];                              // status of the chest lamps for each player / one column per byte
byte PB_Chest_Status[5];                              // number of visor openings for this player / > 100 means visor is actually open
byte PB_Planet[5];                                    // reached planets for all players
byte PB_ExBallsLit[5];                                // no of lanes lit for extra ball
byte PB_EjectMode[5];                                 // current mode of the eject hole
byte PB_EnergyValue[5];                               // energy value for current player (value = byte*2000)
byte PB_LampsToLight = 2;                             // number of lamps to light when chest is hit
byte *PB_ChestPatterns;                               // pointer to the current chest lamp pattern
byte PB_MballState = 1;                               // status variable for the 3 ball multiball feature

const unsigned int PB_SolTimes[32] = {50,30,30,70,50,200,30,30,0,0,0,0,0,0,150,150,50,0,50,50,50,50,0,0,50,150,150,150,150,150,150,100}; // Activation times for solenoids (last 8 are C bank)
const byte PB_BallSearchCoils[8] = {3,4,5,17,19,22,6,0}; // coils to fire when the ball watchdog timer runs out
const byte PB_OpenVisorSeq[137] = {26,1,29,9,15,4,16,2, 32,9,15,1,31,9,26,1,27,9, 29,2,28,9,32,2,29,7, 26,5,15,6,16,2,31,5,15,7, 26,4,27,7,29,6,28,9, 29,5,26,7,15,5,16,5,32,5, 15,4,31,5,26,7,29,5,27,11, 28,1,29,12,26,4,32,9, 15,3,31,7,16,5,27,5,15,3, 28,7,26,2,29,7,32,10 ,29,2,31,10,26,3,27,2,31,5, 15,2,28,9,16,4,15,1, 32,10,26,3,31,9,29,4,27,12, 28,2,29,10,26,2,15,7, 32,4,16,5,31,4,15,7,26,5,0};
const byte PB_MultiballSeq[69] = {16,5,15,5,26,5,29,10,26,5,15,5,16,10,15,5,26,5,29,10,26,5,15,5,16,10,15,5,26,5,29,10,7,0,26,5,15,5,16,10,15,5,26,5,29,10,26,5,15,5,16,10,15,5,26,5,29,10,26,5,15,5,16,5,15,10,8,0,0};
const byte PB_ScoreEnergySeq[7] = {31,10,31,10,31,10,0};
const byte PB_LeftBBinserts[5] = {28, 20, 28, 20, 0};
const byte PB_RightBBinserts[5] = {27, 20, 27, 20, 0};
const byte PB_BB_FlasherCycle[15] = {32, 6, 30, 2, 31, 8, 29, 8, 26, 8, 15, 8, 16, 3, 0};
const byte PB_Ball_Locked[5] = {26,30,26,30,0};
const byte PB_SkillShotFail[25] = {26,10,15,40,26,10,15,40,26,10,15,40,26,10,15,40,26,10,15,40,26,10,15,40,0};
const byte PB_MultiplierSeq[83] = {27,2,29,6,26,7,27,6,15,5,16,8,27,5,29,8,30,5,26,1,31,11,28,1,15,6,31,3,16,3,28,8,27,1,29,9,26,5,27,4,15,4,31,7,16,3,31,7,26,1,29,10,32,1,15,11,30,1,16,4,31,3,29,8,28,6,26,5,31,7,15,1,16,11,29,10,31,2,15,6,16,4,0};
const byte PB_ChestRows[11][5] = {{28,36,44,52,60},{28,29,30,31,32},{36,37,38,39,40},{44,45,46,47,48},{52,53,54,55,56},{60,61,62,63,64},
                                {32,40,48,56,64},{31,39,47,55,63},{30,38,46,54,62},{29,37,45,53,61},{28,36,44,52,60}};
const byte PB_ExBallLamps[4] = {49, 50, 58, 57};
const byte PB_ACselectRelay = 14;                     // solenoid number of the A/C select relay
const char PB_TestSounds[10][15] = {{"1_01L.snd"},{"1_02.snd"},{"1_02L.snd"},{"1_03L.snd"},{"1_04.snd"},{"1_04L.snd"},{"1_05.snd"},{"1_06.snd"},{"1_06L.snd"},0};
const char PB_TxTMballs[2][17] = {{"        2 BALL  "},{"        3 BALL  "}};
const char PB_PlanetTxt[9][17] = {{"       PLUTO    "},{"       NEPTUNE  "},{"       URANUS   "},{"       SATURN   "},{"       JUPITER  "},{"       MARS     "},{"       EARTH    "},{"       VENUS    "},{"       MERCURY  "}};

const struct SettingTopic PB_setList[11] = {{"DROP TG TIME  ",HandleNumSetting,0,3,30},
    {" REACH PLANET ",HandleTextSetting,&PB_PlanetTxt[0][0],0,8},
    {" ENERGY TIMER ",HandleNumSetting,0,1,90},
    {"  BALL  SAVER ",HandleBoolSetting,0,0,0},
    {"  MULTIBALL   ",HandleTextSetting,&PB_TxTMballs[0][0],0,1},
    {" EJECT STRNGTH",HandleNumSetting,0,10,50},
    {"  HOLD  TIME  ",HandleNumSetting,0,5,30},
    {" RESET  HIGH  ",PB_ResetHighScores,0,0,0},
    {"RESTOREDEFAULT",RestoreDefaults,0,0,0},
    {"  EXIT SETTNGS",ExitSettings,0,0,0},
    {"",NULL,0,0,0}};

                                                      // offsets of settings in the settings array
#define PB_DropTime 0                                 // drop target down time setting
#define PB_ReachPlanet 1                              // target planet setting
#define PB_EnergyTime 2                               // energy timer setting
#define PB_BallSaver 3                                // ball saver for the outlanes
#define PB_Multiballs 4                               // to switch between 2 and 3 ball Multiball
#define PB_BallEjectStrength 5                        // activation time of the ball ramp thrower (solenoid 1A) in ms
#define PB_MballHoldTime 6                            // time for balls to be held in eject holes during 3 ball Multiball

const byte PB_defaults[64] = {15,6,15,0,0,30,10,0,     // game default settings
                               0,0,0,0,0,0,0,0,
                               0,0,0,0,0,0,0,0,
                               0,0,0,0,0,0,0,0,
                               0,0,0,0,0,0,0,0,
                               0,0,0,0,0,0,0,0,
                               0,0,0,0,0,0,0,0,
                               0,0,0,0,0,0,0,0};

                                     // Duration..11111110...22222111...33322222...43333333...44444444...55555554...66666555
                                     // Duration..65432109...43210987...21098765...09876543...87654321...65432109...43210987

const struct LampPat PB_EjectHole[43] = {{40,0,0b00000000,0b00000000,0b00000000,0b00000000,0b00000000,0b00000010,0b00000100},
                                          {40,0,0b00000000,0b00000000,0b00000000,0b00000001,0b00000000,0b00000010,0b00000101},
                                          {40,0,0b00000100,0b00000000,0b00000000,0b00000001,0b00000000,0b00000010,0b00000111},
                                          {40,0,0b00001110,0b00000000,0b00000000,0b00000001,0b00000000,0b00000010,0b00000111},
                                          {40,0,0b00001111,0b01000000,0b00000000,0b00000001,0b00000000,0b00000010,0b00000111},
                                          {40,0,0b00001111,0b11000010,0b00000000,0b00000001,0b00000000,0b00000110,0b00000111},
                                          {40,0,0b00001111,0b11100010,0b00000111,0b00000001,0b00000000,0b00000100,0b00000111},
                                          {40,0,0b00001111,0b11110010,0b00000111,0b00000001,0b00000000,0b00000111,0b00000111},
                                          {40,0,0b00001111,0b11110010,0b00000111,0b00000001,0b00000000,0b00000111,0b00000111},
                                          {40,0,0b00001111,0b11111110,0b00000111,0b00000001,0b00000000,0b00000111,0b10000111},
                                          {40,0,0b00001111,0b11111110,0b00000111,0b00000001,0b00000000,0b10000111,0b11000111},
                                          {40,0,0b00001111,0b11111110,0b00000111,0b00000001,0b10000000,0b11000111,0b11100111},
                                          {40,0,0b00001111,0b11111110,0b00000111,0b10000001,0b11000000,0b11100111,0b11110111},
                                          {40,0,0b00001111,0b11111111,0b10000111,0b11000001,0b11100100,0b11110111,0b11111111},
                                          {40,0,0b00001111,0b11111111,0b11000111,0b11100001,0b11110110,0b11111111,0b11111111},
                                          {40,0,0b00001111,0b11111111,0b11100111,0b11110001,0b11111111,0b11111111,0b11111111},
                                          {40,0,0b00001111,0b11111111,0b11110111,0b11111101,0b11111111,0b11111111,0b11111111},
                                          {40,0,0b00001111,0b11111111,0b11111111,0b11111101,0b11111111,0b11111111,0b11111111},
                                          {40,0,0b10001111,0b11111111,0b11111111,0b11111101,0b11111111,0b11111111,0b11111111},
                                          {40,0,0b10011111,0b11111111,0b11111111,0b11111111,0b11111111,0b11111111,0b11111111},
                                          {40,0,0b10111111,0b11111111,0b11111111,0b11111111,0b11111111,0b11111111,0b11111111},
                                          {40,0,0b11111111,0b11111111,0b11111111,0b11111111,0b11111111,0b11111101,0b11111011},
                                          {40,0,0b11111111,0b11111111,0b11111111,0b11111110,0b11111111,0b11111101,0b11111010},
                                          {40,0,0b11111011,0b11111111,0b11111111,0b11111110,0b11111111,0b11111101,0b11111000},
                                          {40,0,0b11110001,0b11111111,0b11111111,0b11111110,0b11111111,0b11111101,0b11111000},
                                          {40,0,0b11110000,0b10111111,0b11111111,0b11111110,0b11111111,0b11111101,0b11111000},
                                          {40,0,0b11110000,0b00111101,0b11111111,0b11111110,0b11111111,0b11111001,0b11111000},
                                          {40,0,0b11110000,0b00011101,0b11111000,0b11111110,0b11111111,0b11111011,0b11111000},
                                          {40,0,0b11110000,0b00001101,0b11111000,0b11111110,0b11111111,0b11111000,0b11111000},
                                          {40,0,0b11110000,0b00001101,0b11111000,0b11111110,0b11111111,0b11111000,0b11111000},
                                          {40,0,0b11110000,0b00000001,0b11111000,0b11111110,0b11111111,0b11111000,0b01111000},
                                          {40,0,0b11110000,0b00000001,0b11111000,0b11111110,0b11111111,0b01111000,0b00111000},
                                          {40,0,0b11110000,0b00000001,0b11111000,0b11111110,0b01111111,0b00111000,0b00011000},
                                          {40,0,0b11110000,0b00000001,0b11111000,0b01111110,0b00111111,0b00011000,0b00001000},
                                          {40,0,0b11110000,0b00000000,0b01111000,0b00111110,0b00011011,0b00001000,0b00000000},
                                          {40,0,0b11110000,0b00000000,0b00111000,0b00011110,0b00001001,0b00000000,0b00000000},
                                          {40,0,0b11110000,0b00000000,0b00011000,0b00001110,0b00000000,0b00000000,0b00000000},
                                          {40,0,0b11110000,0b00000000,0b00001000,0b00000010,0b00000000,0b00000000,0b00000000},
                                          {40,0,0b11110000,0b00000000,0b00000000,0b00000010,0b00000000,0b00000000,0b00000000},
                                          {40,0,0b01110000,0b00000000,0b00000000,0b00000010,0b00000000,0b00000000,0b00000000},
                                          {40,0,0b01100000,0b00000000,0b00000000,0b00000000,0b00000000,0b00000000,0b00000000},
                                          {40,0,0b01000000,0b00000000,0b00000000,0b00000000,0b00000000,0b00000000,0b00000000},
                                          {0,0,0,0,0,0,0,0,0}};

const struct LampPat PB_EnergyPat[43] =  {{16,0,0b01000000,0b00000000,0b00000000,0b00000000,0b00000000,0b00000000,0b00000000},
                                          {16,0,0b01100000,0b00000000,0b00000000,0b00000000,0b00000000,0b00000000,0b00000000},
                                          {16,0,0b01110000,0b00000000,0b00000000,0b00000010,0b00000000,0b00000000,0b00000000},
                                          {16,0,0b11110000,0b00000000,0b00000000,0b00000010,0b00000000,0b00000000,0b00000000},
                                          {16,0,0b11110000,0b00000000,0b00001000,0b00000010,0b00000000,0b00000000,0b00000000},
                                          {16,0,0b11110000,0b00000000,0b00011000,0b00001110,0b00000000,0b00000000,0b00000000},
                                          {16,0,0b11110000,0b00000000,0b00111000,0b00011110,0b00001001,0b00000000,0b00000000},
                                          {16,0,0b11110000,0b00000000,0b01111000,0b00111110,0b00011011,0b00001000,0b00000000},
                                          {16,0,0b11110000,0b00000001,0b11111000,0b01111110,0b00111111,0b00011000,0b00001000},
                                          {16,0,0b11110000,0b00000001,0b11111000,0b11111110,0b01111111,0b00111000,0b00011000},
                                          {16,0,0b11110000,0b00000001,0b11111000,0b11111110,0b11111111,0b01111000,0b00111000},
                                          {16,0,0b11110000,0b00000001,0b11111000,0b11111110,0b11111111,0b11111000,0b01111000},
                                          {16,0,0b11110000,0b00001101,0b11111000,0b11111110,0b11111111,0b11111000,0b11111000},
                                          {16,0,0b11110000,0b00001101,0b11111000,0b11111110,0b11111111,0b11111000,0b11111000},
                                          {16,0,0b11110000,0b00011101,0b11111000,0b11111110,0b11111111,0b11111011,0b11111000},
                                          {16,0,0b11110000,0b00111101,0b11111111,0b11111110,0b11111111,0b11111001,0b11111000},
                                          {16,0,0b11110000,0b10111111,0b11111111,0b11111110,0b11111111,0b11111101,0b11111000},
                                          {16,0,0b11110001,0b11111111,0b11111111,0b11111110,0b11111111,0b11111101,0b11111000},
                                          {16,0,0b11111011,0b11111111,0b11111111,0b11111110,0b11111111,0b11111101,0b11111000},
                                          {16,0,0b11111111,0b11111111,0b11111111,0b11111110,0b11111111,0b11111101,0b11111010},
                                          {16,0,0b11111111,0b11111111,0b11111111,0b11111111,0b11111111,0b11111101,0b11111011},
                                          {16,0,0b10111111,0b11111111,0b11111111,0b11111111,0b11111111,0b11111111,0b11111111},
                                          {16,0,0b10011111,0b11111111,0b11111111,0b11111111,0b11111111,0b11111111,0b11111111},
                                          {16,0,0b10001111,0b11111111,0b11111111,0b11111101,0b11111111,0b11111111,0b11111111},
                                          {16,0,0b00001111,0b11111111,0b11111111,0b11111101,0b11111111,0b11111111,0b11111111},
                                          {16,0,0b00001111,0b11111111,0b11110111,0b11111101,0b11111111,0b11111111,0b11111111},
                                          {16,0,0b00001111,0b11111111,0b11100111,0b11110001,0b11111111,0b11111111,0b11111111},
                                          {16,0,0b00001111,0b11111111,0b11000111,0b11100001,0b11110110,0b11111111,0b11111111},
                                          {16,0,0b00001111,0b11111111,0b10000111,0b11000001,0b11100100,0b11110111,0b11111111},
                                          {16,0,0b00001111,0b11111110,0b00000111,0b10000001,0b11000000,0b11100111,0b11110111},
                                          {16,0,0b00001111,0b11111110,0b00000111,0b00000001,0b10000000,0b11000111,0b11100111},
                                          {16,0,0b00001111,0b11111110,0b00000111,0b00000001,0b00000000,0b10000111,0b11000111},
                                          {16,0,0b00001111,0b11111110,0b00000111,0b00000001,0b00000000,0b00000111,0b10000111},
                                          {16,0,0b00001111,0b11110010,0b00000111,0b00000001,0b00000000,0b00000111,0b00000111},
                                          {16,0,0b00001111,0b11110010,0b00000111,0b00000001,0b00000000,0b00000111,0b00000111},
                                          {16,0,0b00001111,0b11100010,0b00000111,0b00000001,0b00000000,0b00000100,0b00000111},
                                          {16,0,0b00001111,0b11000010,0b00000000,0b00000001,0b00000000,0b00000110,0b00000111},
                                          {16,0,0b00001111,0b01000000,0b00000000,0b00000001,0b00000000,0b00000010,0b00000111},
                                          {16,0,0b00001110,0b00000000,0b00000000,0b00000001,0b00000000,0b00000010,0b00000111},
                                          {16,0,0b00000100,0b00000000,0b00000000,0b00000001,0b00000000,0b00000010,0b00000111},
                                          {16,0,0b00000000,0b00000000,0b00000000,0b00000001,0b00000000,0b00000010,0b00000101},
                                          {16,0,0b00000000,0b00000000,0b00000000,0b00000000,0b00000000,0b00000010,0b00000100},
                                          {0,0,0,0,0,0,0,0,0}};

const struct LampPat PB_MultiballPat[20] ={{320,0,0b01000000,0b00000000,0b00000000,0b00000000,0b00000000,0b00000000,0b00000000},
                                           {320,0,0b01100000,0b00000000,0b00000000,0b00000000,0b00000000,0b00000000,0b00000000},
                                           {320,0,0b01110000,0b00000000,0b00000000,0b00000000,0b00000000,0b00000000,0b00000000},
                                           {320,0,0b11110000,0b00000000,0b00000000,0b00000010,0b00000000,0b00000000,0b00000000},
                                           {320,0,0b11110000,0b00000000,0b00001000,0b00001010,0b00001000,0b00001000,0b00001000},
                                           {320,0,0b11110000,0b00000000,0b00011000,0b00011010,0b00011000,0b00011000,0b00011000},
                                           {320,0,0b11110000,0b00000000,0b00111000,0b00111010,0b00111000,0b00111000,0b00111000},
                                           {320,0,0b11110000,0b00000000,0b01111000,0b01111110,0b01111000,0b01111000,0b01111000},
                                           {320,0,0b11110000,0b00000000,0b11111000,0b11111110,0b11111001,0b11111000,0b11111000},
                                           {320,0,0b11110000,0b00000001,0b11111000,0b11111110,0b11111011,0b11111000,0b11111000},
                                           {320,0,0b11110000,0b00000001,0b11111000,0b11111110,0b11111111,0b11111000,0b11111000},
                                           {320,0,0b11110000,0b00011001,0b11111000,0b11111110,0b11111111,0b11111000,0b11111000},
                                           {320,0,0b11110000,0b00111111,0b11111000,0b11111110,0b11111111,0b11111000,0b11111000},
                                           {320,0,0b11110000,0b00111111,0b11111100,0b11111110,0b11111111,0b11111100,0b11111000},
                                           {320,0,0b11110000,0b01111111,0b11111110,0b11111110,0b11111111,0b11111100,0b11111000},
                                           {320,0,0b11110000,0b11111111,0b11111111,0b11111110,0b11111111,0b11111111,0b11111011},
                                           {320,0,0b11110011,0b11111111,0b11111111,0b11111110,0b11111111,0b11111111,0b11111011},
                                           {320,0,0b11111111,0b11111111,0b11111111,0b11111110,0b11111111,0b11111111,0b11111011},
                                           {320,0,0b11111111,0b11111111,0b11111111,0b11111111,0b11111111,0b11111111,0b11111011},
                                           {0,0,0,0,0,0,0,0,0}};

const struct LampPat PB_AttractPat1[5] = {{150,0,0b00000000,0b00000000,0b00000000,0b00000000,0b00100000,0b00000000,0b00000000},
                                          {150,0,0b00000000,0b00000000,0b00000000,0b01110000,0b01110000,0b01110000,0b00000000},
                                          {150,0,0b00000000,0b00000000,0b11111000,0b11111000,0b11011000,0b11111000,0b11111000},
                                          {150,0,0b10000000,0b00111111,0b11111000,0b10001000,0b10001000,0b10001000,0b11111000},
                                          {0,0,0,0,0,0,0,0,0}};

const struct LampPat PB_AttractPat2[5] = {{150,0,0b00010000,0b11000000,0b00000111,0b00000110,0b00100001,0b00000110,0b00000010},
                                          {150,0,0b00100011,0b00000000,0b00000000,0b01110000,0b01110010,0b01110001,0b00000001},
                                          {150,0,0b01001100,0b00000000,0b11111000,0b11111001,0b11011100,0b11111000,0b11111000},
                                          {150,0,0b10000000,0b00111111,0b11111000,0b10001000,0b10001000,0b10001000,0b11111000},
                                          {0,0,0,0,0,0,0,0,0}};

const struct LampPat PB_AttractPat3[4] = {{150,0,0b00010000,0b11000000,0b00000111,0b00000110,0b00000001,0b00000110,0b00000010},
                                          {150,0,0b00100011,0b00000000,0b00000000,0b00000000,0b00000010,0b00000001,0b00000001},
                                          {150,0,0b01001100,0b00000000,0b00000000,0b00000001,0b00000100,0b00000000,0b00000000},
                                          {0,0,0,0,0,0,0,0,0}};

const struct LampPat PB_AttractPat4[36] ={{150,0,0b10000001,0b00000101,0b10000000,0b00000000,0b00000000,0b00000001,0b00000000},
                                          {150,0,0b10010011,0b00001101,0b11000000,0b00000100,0b00000000,0b00000011,0b00000000},
                                          {150,0,0b00110110,0b00011000,0b11100000,0b00000100,0b00000001,0b00000010,0b00000010},
                                          {150,0,0b01100100,0b00110000,0b11110000,0b00000001,0b00000011,0b00000000,0b00000011},
                                          {150,0,0b01001000,0b01100000,0b11111000,0b00000011,0b00000110,0b00000100,0b00000001},
                                          {150,0,0b10001001,0b11000011,0b01111000,0b00001010,0b00000100,0b00000100,0b00000011},
                                          {150,0,0b10010011,0b10000011,0b00111001,0b00001100,0b00001000,0b00000010,0b00000010},
                                          {150,0,0b00110110,0b00000000,0b00011011,0b00001100,0b00001001,0b00001011,0b00000000},
                                          {150,0,0b01100100,0b00000000,0b00001110,0b00001001,0b00001011,0b00001001,0b00001000},
                                          {150,0,0b01001000,0b00000000,0b00000100,0b00001011,0b00001110,0b00001011,0b00011000},
                                          {150,0,0b10001001,0b00000001,0b00000000,0b00000010,0b00001100,0b00001010,0b00111010},
                                          {150,0,0b10010011,0b00000101,0b00000000,0b00000100,0b00000000,0b00001000,0b01111011},
                                          {150,0,0b00110110,0b00001100,0b00000000,0b00000100,0b00000001,0b00000000,0b11111001},
                                          {150,0,0b01100100,0b00011000,0b00000000,0b00000001,0b00000011,0b10000000,0b11110011},
                                          {150,0,0b01001000,0b00110000,0b00000000,0b00000011,0b10000110,0b10000010,0b11100010},
                                          {150,0,0b10001001,0b01100001,0b00000000,0b10000010,0b10000100,0b10000111,0b11000000},
                                          {150,0,0b10010011,0b11000011,0b00000000,0b11000100,0b10000000,0b10000101,0b10000000},
                                          {150,0,0b00110110,0b10000010,0b00000001,0b11100100,0b10000001,0b10000011,0b00000000},
                                          {150,0,0b01100100,0b00000000,0b00000011,0b11110001,0b10000011,0b00000010,0b00000010},
                                          {150,0,0b01001000,0b00000000,0b00000110,0b11110011,0b00010110,0b00000000,0b00000011},
                                          {150,0,0b10001001,0b00000001,0b00000100,0b01110010,0b00010100,0b00010000,0b00000001},
                                          {150,0,0b10010011,0b00000001,0b00000000,0b00110100,0b00010000,0b00110000,0b00000011},
                                          {150,0,0b00110110,0b00000100,0b00000000,0b00010100,0b00010001,0b01110010,0b00000010},
                                          {150,0,0b01100100,0b00001100,0b00000000,0b00000001,0b01010011,0b01110011,0b00000000},
                                          {150,0,0b01001000,0b00011000,0b00000000,0b00000011,0b01100110,0b01110001,0b00000000},
                                          {150,0,0b10001001,0b00110001,0b00000000,0b00000010,0b01100100,0b01100011,0b00000000},
                                          {150,0,0b10010011,0b01100001,0b00000000,0b00000100,0b01100000,0b01000110,0b00000010},
                                          {150,0,0b00110110,0b11000010,0b00000000,0b00000100,0b01100001,0b00000100,0b00000011},
                                          {150,0,0b01100100,0b10000010,0b00000001,0b00000001,0b00100011,0b00000000,0b00000001},
                                          {150,0,0b01001000,0b00000000,0b00000011,0b00000011,0b00000110,0b00000000,0b00000011},
                                          {150,0,0b10010001,0b00000001,0b00000011,0b00000010,0b00000100,0b00000010,0b00000010},
                                          {150,0,0b10010011,0b00000001,0b00000110,0b00000100,0b00000000,0b00000011,0b00000000},
                                          {150,0,0b00110110,0b00000000,0b00000100,0b00000100,0b00000000,0b00000001,0b00000000},
                                          {150,0,0b00100100,0b00000000,0b00000000,0b00000000,0b00000000,0b00000000,0b00000000},
                                          {150,0,0b00000000,0b00000000,0b00000000,0b00000000,0b00000000,0b00000000,0b00000000},
                                          {0,0,0,0,0,0,0,0,0}};
                                      // Duration..11111110...22222111...33322222...43333333...44444444...55555554...66666555
                                      // Duration..65432109...43210987...21098765...09876543...87654321...65432109...43210987
//const struct LampPat PB_AttractPat5[] =  {{150,0,0b00000000,0b00000000,0b00000000,0b00000000,0b00000000,0b00000000,0b00000001},
//                                          {150,0,0b00000000,0b00000010,0b00000000,0b00000000,0b00000000,0b00000000,0b00000001},
//                                          {150,0,0b00000000,0b00000010,0b00000000,0b00000000,0b00000000,0b00000000,0b00000011},
//                                          {150,0,0b00000000,0b00000010,0b00000000,0b00000000,0b00000000,0b00000100,0b00000010},
//                                          {150,0,0b00000000,0b01100000,0b00000000,0b00000000,0b00000000,0b00000100,0b00000010},
//                                          {150,0,0b00000000,0b01100000,0b00000000,0b00000000,0b00000000,0b00000100,0b11111000},
//                                          {150,0,0b00000110,0b11100000,0b00000000,0b00000000,0b00000000,0b11111000,0b11111001},
//                                          {150,0,0b00000110,0b10010010,0b00000000,0b00000001,0b11111000,0b11111000,0b11111001},
//                                          {150,0,0b00001111,0b00010010,0b00000101,0b11111001,0b11111000,0b11111000,0b00000011},
//                                          {150,0,0b00001001,0b00011010,0b11111111,0b11111001,0b11111000,0b00000100,0b00000010},
//
//                                          {150,0,0b10001001,0b01101011,0b11111111,0b11111000,0b00000000,0b00000100,0b00000010},
//                                          {150,0,0b11110000,0b11101101,0b11111010,0b00000100,0b00000000,0b00000100,0b11111000},
//                                          {150,0,0b11110110,0b11100101,0b00000000,0b00000100,0b00000111,0b11111010,0b11111001},
//                                          {150,0,0b01110110,0b10010100,0b00000000,0b00000111,0b11111000,0b11111011,0b11111001},
//                                          {150,0,0b00001111,0b00011010,0b00000101,0b11111011,0b11111000,0b11111001,0b00000011},
//                                          {150,0,0b00001001,0b00011010,0b11111111,0b11111011,0b11111000,0b00000001,0b00000011},
//
//                                          {150,0,0b10001001,0b01101011,0b11111111,0b11111000,0b00000000,0b00000100,0b00000010},
//                                          {150,0,0b11110000,0b11101101,0b11111010,0b00000100,0b00000000,0b00000100,0b11111000},
//                                          {150,0,0b11110110,0b11100101,0b00000000,0b00000100,0b00000111,0b11111010,0b11111001},
//                                          {150,0,0b01110110,0b10010100,0b00000000,0b00000111,0b11111000,0b11111011,0b11111001},
//                                          {150,0,0b00001111,0b00011010,0b00000101,0b11111011,0b11111000,0b11111001,0b00000011},
//                                          {150,0,0b00001001,0b00011010,0b11111111,0b11111011,0b11111000,0b00000001,0b00000011},
//                                          {150,0,0b10001001,0b01101011,0b11111111,0b11111000,0b00000000,0b00000100,0b00000010},
//                                          {150,0,0b11110000,0b11101101,0b11111010,0b00000100,0b00000000,0b00000100,0b11111000},
//                                          {150,0,0b11110110,0b11100101,0b00000000,0b00000100,0b00000111,0b11111010,0b11111001},
//                                          {150,0,0b01110110,0b10010100,0b00000000,0b00000111,0b11111000,0b11111011,0b11111001},
//                                          {150,0,0b00001111,0b00011010,0b00000101,0b11111011,0b11111000,0b11111001,0b00000011},
//                                          {150,0,0b00001001,0b00011010,0b11111111,0b11111011,0b11111000,0b00000001,0b00000011},
//                                          {150,0,0b00000000,0b00000000,0b00000000,0b00000000,0b00000000,0b00000000,0b00000000},
//                                          {150,0,0b00000000,0b00000000,0b00000000,0b00000000,0b00000000,0b00000000,0b00000000},
//                                          {150,0,0b00000000,0b00000000,0b00000000,0b00000000,0b00000000,0b00000000,0b00000000},
//                                          {150,0,0b00000000,0b00000000,0b00000000,0b00000000,0b00000000,0b00000000,0b00000000},
//                                          {150,0,0b00000000,0b00000000,0b00000000,0b00000000,0b00000000,0b00000000,0b00000000},
//                                          {150,0,0b00000000,0b00000000,0b00000000,0b00000000,0b00000000,0b00000000,0b00000000},
//                                          {150,0,0b00000000,0b00000000,0b00000000,0b00000000,0b00000000,0b00000000,0b00000000},
//                                          {150,0,0b00000000,0b00000000,0b00000000,0b00000000,0b00000000,0b00000000,0b00000000},
//                                          {150,0,0b00000000,0b00000000,0b00000000,0b00000000,0b00000000,0b00000000,0b00000000},
//                                          {150,0,0b00000000,0b00000000,0b00000000,0b00000000,0b00000000,0b00000000,0b00000000},
//                                          {150,0,0b00000000,0b00000000,0b00000000,0b00000000,0b00000000,0b00000000,0b00000000},
//                                          {150,0,0b00000000,0b00000000,0b00000000,0b00000000,0b00000000,0b00000000,0b00000000},
//                                          {150,0,0b00000000,0b00000000,0b00000000,0b00000000,0b00000000,0b00000000,0b00000000},
//                                          {150,0,0b00000000,0b00000000,0b00000000,0b00000000,0b00000000,0b00000000,0b00000000},
//                                          {150,0,0b00000000,0b00000000,0b00000000,0b00000000,0b00000000,0b00000000,0b00000000},
//                                          {150,0,0b00000000,0b00000000,0b00000000,0b00000000,0b00000000,0b00000000,0b00000000},
//                                          {150,0,0b00000000,0b00000000,0b00000000,0b00000000,0b00000000,0b00000000,0b00000000},
//                                          {150,0,0b00000000,0b00000000,0b00000000,0b00000000,0b00000000,0b00000000,0b00000000},
//                                          {150,0,0b00000000,0b00000000,0b00000000,0b00000000,0b00000000,0b00000000,0b00000000},
//
//}
const struct LampFlow PB_AttractFlow[5] = {{1,PB_AttractPat1},{10,PB_AttractPat2},{1,PB_AttractPat3},{2,PB_AttractPat4},{0,0}};

const byte PB_GameStartPat[163] = {10,0b11111,0b11111,0b11111,0b11111,0b11111,
                                   10,0b00000,0b00000,0b00000,0b00000,0b00000,
                                   10,0b11111,0b11111,0b11111,0b11111,0b11111,
                                   10,0b00000,0b00000,0b00000,0b00000,0b00000,
                                   10,0b11111,0b11111,0b11111,0b11111,0b11111,
                                   10,0b00000,0b00000,0b00000,0b00000,0b00000,
                                   10,0b11111,0b11111,0b11111,0b11111,0b11111,
                                   10,0b00000,0b00000,0b00000,0b00000,0b00000,
                                   10,0b11111,0b11111,0b11111,0b11111,0b11111,
                                   10,0b00000,0b00000,0b00000,0b00000,0b00000,
                                   10,0b11111,0b11111,0b11111,0b11111,0b11111,
                                   10,0b00000,0b00000,0b00000,0b00000,0b00000,
                                   10,0b11111,0b11111,0b11111,0b11111,0b11111,
                                   10,0b00000,0b00000,0b00000,0b00000,0b00000,
                                   10,0b11111,0b11111,0b11111,0b11111,0b11111,
                                   10,0b00000,0b00000,0b00000,0b00000,0b00000,
                                   10,0b11111,0b11111,0b11111,0b11111,0b11111,
                                   10,0b00000,0b00000,0b00000,0b00000,0b00000,
                                   10,0b11111,0b11111,0b11111,0b11111,0b11111,
                                   10,0b00000,0b00000,0b00000,0b00000,0b00000,
                                   10,0b11111,0b11111,0b11111,0b11111,0b11111,
                                   10,0b00000,0b00000,0b00000,0b00000,0b00000,
                                   10,0b11111,0b11111,0b11111,0b11111,0b11111,
                                   10,0b00000,0b00000,0b00000,0b00000,0b00000,
                                   10,0b11111,0b11111,0b11111,0b11111,0b11111,
                                   10,0b00000,0b00000,0b00000,0b00000,0b00000,
                                   10,0b11111,0b11111,0b11111,0b11111,0b11111,0};

const byte PB_OpenVisorPat[163] = {100,0b11111,0b11111,0b11111,0b11111,0b11111,
                                    50,0b00000,0b00000,0b00000,0b00000,0b00000,
                                    50,0b11111,0b11111,0b11111,0b11111,0b11111,
                                    50,0b00000,0b00000,0b00000,0b00000,0b00000,
                                    30,0b11111,0b11111,0b11111,0b11111,0b11111,
                                    30,0b00000,0b00000,0b00000,0b00000,0b00000,
                                    14,0b11111,0b11111,0b11111,0b11111,0b11111,
                                    22,0b00000,0b00000,0b00000,0b00000,0b00000,
                                    14,0b11111,0b11111,0b11111,0b11111,0b11111,
                                    17,0b00000,0b00000,0b00000,0b00000,0b00000,
                                    11,0b11111,0b11111,0b11111,0b11111,0b11111,
                                    14,0b00000,0b00000,0b00000,0b00000,0b00000,
                                    11,0b11111,0b11111,0b11111,0b11111,0b11111,
                                    11,0b00000,0b00000,0b00000,0b00000,0b00000,
                                    7,0b11111,0b11111,0b11111,0b11111,0b11111,
                                    11,0b00000,0b00000,0b00000,0b00000,0b00000,
                                    7,0b11111,0b11111,0b11111,0b11111,0b11111,
                                    8,0b00000,0b00000,0b00000,0b00000,0b00000,
                                    4,0b11111,0b11111,0b11111,0b11111,0b11111,
                                    4,0b00000,0b00000,0b00000,0b00000,0b00000,
                                    4,0b11111,0b11111,0b11111,0b11111,0b11111,
                                    4,0b00000,0b00000,0b00000,0b00000,0b00000,
                                    4,0b11111,0b11111,0b11111,0b11111,0b11111,
                                    4,0b00000,0b00000,0b00000,0b00000,0b00000,
                                    4,0b11111,0b11111,0b11111,0b11111,0b11111,
                                    4,0b00000,0b00000,0b00000,0b00000,0b00000,
                                    4,0b11111,0b11111,0b11111,0b11111,0b11111,0};

const byte PB_RandomChestPat[25] =  {15,0b10011,0b00100,0b01100,0b10101,0b00101,
                                     15,0b11100,0b00101,0b10011,0b10100,0b10010,
                                     15,0b00101,0b11010,0b10110,0b01011,0b01101,
                                     15,0b01010,0b11011,0b01001,0b01010,0b11010,0};

const byte PB_ExpandingSquares[37] = {10,0b00000,0b00000,0b00100,0b00000,0b00000,
                                    10,0b00000,0b01110,0b01110,0b01110,0b00000,
                                    10,0b11111,0b11111,0b11111,0b11111,0b11111,
                                    10,0b11111,0b11111,0b11011,0b11111,0b11111,
                                    10,0b11111,0b10001,0b10001,0b10001,0b11111,
                                    15,0b00000,0b00000,0b00000,0b00000,0b00000,0};

const byte PB_WalkingLines[199] = {15,0b01000,0b01000,0b01000,0b01000,0b01000,
                                   15,0b00100,0b00100,0b00100,0b00100,0b00100,
                                   15,0b00010,0b00010,0b00010,0b00010,0b00010,
                                   15,0b00001,0b00001,0b00001,0b00001,0b00001,
                                   15,0b00001,0b00010,0b00010,0b00100,0b01000,
                                   15,0b00001,0b00010,0b00100,0b01000,0b10000,
                                   15,0b00001,0b00110,0b11000,0b00000,0b00000,
                                   15,0b11111,0b00000,0b00000,0b00000,0b00000,
                                   15,0b00000,0b11111,0b00000,0b00000,0b00000,
                                   15,0b00000,0b00000,0b11111,0b00000,0b00000,
                                   15,0b00000,0b00000,0b00000,0b11111,0b00000,
                                   15,0b00000,0b00000,0b00000,0b00000,0b11111,                                  
                                   15,0b00000,0b00000,0b11000,0b00110,0b00001,
                                   15,0b10000,0b01000,0b00100,0b00010,0b00001,
                                   15,0b00100,0b00100,0b00010,0b00010,0b00001,
                                   15,0b00001,0b00001,0b00001,0b00001,0b00001,
                                   15,0b00010,0b00010,0b00010,0b00010,0b00010,
                                   15,0b00100,0b00100,0b00100,0b00100,0b00100,
                                   15,0b01000,0b01000,0b01000,0b01000,0b01000,
                                   15,0b10000,0b10000,0b10000,0b10000,0b10000,
                                   15,0b00100,0b00100,0b01000,0b01000,0b10000,                                   
                                   15,0b00001,0b00010,0b00100,0b01000,0b10000,
                                   15,0b00000,0b00000,0b00110,0b01100,0b10000,
                                   15,0b00000,0b00000,0b00000,0b00000,0b11111,
                                   15,0b00000,0b00000,0b00000,0b11111,0b00000,
                                   15,0b00000,0b00000,0b11111,0b00000,0b00000,
                                   15,0b00000,0b11111,0b00000,0b00000,0b00000,
                                   15,0b11111,0b00000,0b00000,0b00000,0b00000,
                                   15,0b10000,0b01100,0b00110,0b00000,0b00000,
                                   15,0b10000,0b01000,0b00100,0b00010,0b00001,
                                   15,0b10000,0b01000,0b01000,0b00100,0b00100,
                                   15,0b10000,0b10000,0b10000,0b10000,0b10000,0};

const byte PB_Characters[185] = {0,0,0,0,0,12,18,18,18,12,4,12,4,4,14,12,18,4,8,30,12,2,12,2,12,10,18,30,2,2,28,16,28,2,12,12,16,28,18,12,30,2,4,8,8,12,18,12,18,12,12,18,14,2,12, // Blank,0,1,2,3,4,5,6,7,8,9
                                 12,18,30,18,18,28,18,28,18,28,14,16,16,16,14,28,18,18,18,28,30,16,28,16,30,30,16,28,16,16,14,16,22,18,14,18,18,30,18,18,4,4,4,4,4,14,2,2,10,4,18,20,24,20,18, // a,b,c,d,e,f,g,h,i,j,k
                                 8,8,8,8,14,17,27,21,17,17,17,25,21,19,17,12,18,18,18,12,28,18,28,16,16,12,18,18,22,12,28,18,28,20,18,14,16,12,2,28,14,4,4,4,4,18,18,18,18,12,17,17,10,10,4, // l,m,n,o,p,q,r,s,t,u,v
                                 17,17,21,21,10,17,10,4,10,17,17,10,4,4,4,31,2,4,8,31}; // w,x,y,z

struct GameDef PB_GameDefinition = {
    PB_setList,                                       // GameSettingsList
    (byte*)PB_defaults,                               // GameDefaultsPointer
    "PB_SET.APC",                                     // GameSettingsFileName
    "PBSCORES.APC",                                   // HighScoresFileName
    PB_AttractMode,                                   // AttractMode
    PB_SolTimes};                                     // Default activation times of solenoids

void PB_init() {
  if (APC_settings[DebugMode]) {                      // activate serial interface in debug mode
    Serial.begin(115200);}
  SolRecycleTime[20-1] = 200;                         // set recycle time for both slingshots
  SolRecycleTime[21-1] = 200;
  ACselectRelay = PB_ACselectRelay;                   // assign the number of the A/C select relay
  GameDefinition = PB_GameDefinition;}                // read the game specific settings and highscores

void PB_AttractMode() {
  InLock = 0;
  if (QuerySwitch(25)) {                              // count locked balls
    InLock++;}
  if (QuerySwitch(26)) {
    InLock++;}
  if (QuerySwitch(38)) {                              // and check the eject hole
    InLock++;}
  if (QuerySwitch(16)) {                              // ball in the outhole?
    ActA_BankSol(1);}
  AfterMusic = 0;
  if (APC_settings[Volume]) {                         // system set to digital volume control?
    analogWrite(VolumePin,255-APC_settings[Volume]);} // adjust PWM to volume setting
  else {
    digitalWrite(VolumePin,HIGH);}                    // turn off the digital volume control
  DispRow1 = DisplayUpper;
  DispRow2 = DisplayLower;
  Switch_Pressed = PB_AttractModeSW;
  Switch_Released = DummyProcess;
  AddBlinkLamp(1, 150);                               // blink Game Over lamp
  LampReturn = PB_AttractLampCycle;
  PB_AttractLampCycle(1);
  PB_AttractDisplayCycle(1);}

void PB_AttractDisplayCycle(byte Step) {
  static byte Count = 0;
  static byte Timer0 = 0;
  static byte Timer1 = 0;
  static byte Timer2 = 0;
  static byte Timer3 = 0;
  switch (Step) {
  case 0:                                             // stop command
    if (Timer0) {
      KillTimer(Timer0);
      Timer0 = 0;}
    if (Timer1) {
      KillTimer(Timer1);
      Timer1 = 0;}
    if (Timer2) {
      KillTimer(Timer2);
      Timer2 = 0;}
    if (Timer3) {
      KillTimer(Timer3);
      Timer3 = 0;}
    Count = 0;
    ScrollUpper(100);                                 // stop scrolling
    ScrollLower(100);
    AddScrollUpper(100);
    return;
  case 1:                                             // attract mode title 'page'
    if (Count == 20) {
      Count++;
      Step = 1;
      WriteUpper(" NOW I SEE YOU  ");                 // erase display
      WriteLower("                ");
      PlaySound(55, "0_b0.snd");}                      // 'now I see you'
      //Timer3 = ActivateTimer(3000, 10, PB_AttractDisplayCycle);}
    else if (Count == 40) {
      Timer0 = 0;
      Count++;
      Step = 1;
      LampReturn = PB_RestoreLamps;
      ShowLampPatterns(0);                            // stop lamp animations
      PB_AttractDisplayCycle(0);                      // stop display animations
      for (byte i=0; i< 8; i++) {
        LampColumns[i] = 0;}
      LampPattern = LampColumns;
      PB_RulesDisplay(1);
      Count = 0;
      return;}
    else {
      Count++;
      WriteUpper2("THE APC         ");
      Timer1 = ActivateTimer(50, 5, PB_AttractDisplayCycle);
      Timer3 = ActivateTimer(2000, 7, PB_AttractDisplayCycle);
      WriteLower2("                ");
      Timer2 = ActivateTimer(1400, 6, PB_AttractDisplayCycle);
      if (NoPlayers) {                                // if there were no games before skip the next step
        Step++;}
      else {
        Step = 3;}}
    break;
  case 2:                                             // show scores of previous game
    WriteUpper2("                ");                  // erase display
    WriteLower2("                ");
    for (i=1; i<=NoPlayers; i++) {                    // display the points of all active players
      ShowNumber(8*i-1, Points[i]);}
    Timer1 = ActivateTimer(50, 5, PB_AttractDisplayCycle);
    Timer2 = ActivateTimer(900, 6, PB_AttractDisplayCycle);
    Step++;
    break;
  case 3:                                             // Show highscores
    WriteUpper2("1>     2>     ");
    WriteLower2("              ");
    for (i=0; i<3; i++) {
      *(DisplayUpper2+8+2*i) = DispPattern1[(HallOfFame.Initials[i]-32)*2];
      *(DisplayUpper2+8+2*i+1) = DispPattern1[(HallOfFame.Initials[i]-32)*2+1];
      *(DisplayUpper2+24+2*i) = DispPattern1[(HallOfFame.Initials[3+i]-32)*2];
      *(DisplayUpper2+24+2*i+1) = DispPattern1[(HallOfFame.Initials[3+i]-32)*2+1];}
    ShowNumber(23, HallOfFame.Scores[0]);
    ShowNumber(31, HallOfFame.Scores[1]);
    Timer1 = ActivateTimer(50, 5, PB_AttractDisplayCycle);
    Timer2 = ActivateTimer(900, 6, PB_AttractDisplayCycle);
    Step++;
    break;
  case 4:
    WriteUpper2("3>     4>     ");
    WriteLower2("              ");
    for (i=0; i<3; i++) {
      *(DisplayUpper2+8+2*i) = DispPattern1[(HallOfFame.Initials[6+i]-32)*2];
      *(DisplayUpper2+8+2*i+1) = DispPattern1[(HallOfFame.Initials[6+i]-32)*2+1];
      *(DisplayUpper2+24+2*i) = DispPattern1[(HallOfFame.Initials[9+i]-32)*2];
      *(DisplayUpper2+24+2*i+1) = DispPattern1[(HallOfFame.Initials[9+i]-32)*2+1];}
    ShowNumber(23, HallOfFame.Scores[2]);
    ShowNumber(31, HallOfFame.Scores[3]);
    Timer1 = ActivateTimer(50, 5, PB_AttractDisplayCycle);
    Timer2 = ActivateTimer(900, 6, PB_AttractDisplayCycle);
    Step = 1;
    break;
  case 5:                                             // scrolling routine called here to keep track of the timer
    Timer1 = 0;
    ScrollUpper(0);
    return;
  case 6:
    Timer2 = 0;
    ScrollLower(0);
    return;
  case 7:
    Timer3 = 0;
    WriteUpper2("PINBOT        ");
    AddScrollUpper(0);
    return;
  case 10:
    AddBlinkLamp(1, 150);                             // blink Game Over lamp
    LampReturn = PB_AttractLampCycle;
    PB_AttractLampCycle(1);
    PB_AttractDisplayCycle(1);
    break;}
  PB_CheckForLockedBalls(0);                          // check for a ball in the outhole
  Timer0 = ActivateTimer(4000, Step, PB_AttractDisplayCycle);}  // come back for the next 'page'

void PB_AttractLampCycle(byte Event) {                // play multiple lamp pattern series
  static byte State = 1;
  if (Event) {
    State = 1;}
  if (!State) {
    ActC_BankSol(8);}                                 // light sun flasher
  PatPointer = PB_AttractFlow[State].FlowPat;         // set the pointer to the current series
  FlowRepeat = PB_AttractFlow[State].Repeat;          // set the repetitions
  State++;                                            // increase counter
  if (!PB_AttractFlow[State].Repeat) {                // repetitions of next series = 0?
    State = 0;}                                       // reset counter
  ShowLampPatterns(1);}                               // call the player

void PB_RestoreLamps(byte Dummy) {                    // restore lamps after ShowLampPatterns has run out
  UNUSED(Dummy);
  LampPattern = LampColumns;}

void PB_ShowMessage(byte Seconds) {                   // switch to the second display buffer for Seconds
  static byte Timer = 0;
  static bool Blocked = 0;                            // if seconds = 254 all subsequent ShowMessage commands are blocked
  if (Seconds) {                                      // time <> 0?
    if (Timer) {                                      // timer already running?
      KillTimer(Timer);                               // kill it
      Timer = 0;}
    if (Seconds == 254) {                             // block further commands
      Blocked = true;}
    else if (Seconds == 255) {                        // release the blocking
      Blocked = false;}
    else if (!Blocked) {
      SwitchDisplay(0);                               // switch to DispUpper2 and DispLower2
      Timer =  ActivateTimer(Seconds*1000, 0, PB_ShowMessage);}} // and start timer to come back
  else {                                              // no time specified means the routine called itself
    Timer = 0;                                        // indicate that timer is not running any more
    SwitchDisplay(1);}}                               // switch back to DispRow1

void PB_AttractModeSW(byte Select) {
  switch(Select) {
  case 3:                                             // credit button
    if (!InLock) {                                    // only if all balls have been cleared out
      RemoveBlinkLamp(1);                             // stop the blinking of the game over lamp
      PB_PlayAfterGameSequence(0);                    // stop end of game animation
      LampReturn = PB_RestoreLamps;
      ShowLampPatterns(0);                            // stop lamp animations
      PB_AttractDisplayCycle(0);                      // stop display animations
      PB_RulesDisplay(0);
      PB_RuleLampEffects(0);
      MusicVolume = 0;
      Switch_Pressed = AddPlayerSW;
      for (byte i=0; i< 8; i++) {
        LampColumns[i] = 0;}
      LampPattern = LampColumns;
      TurnOnLamp(3);                                  // turn on Ball in Play lamp
      NoPlayers = 0;
      WriteUpper("              ");
      WriteLower("              ");
      Ball = 1;
      PB_AddPlayer();
      for (byte i=1;i<5;i++) {                        // for all players
        PB_Chest_Status[i] = 0;                       // reset the number of number of visor openings
        PB_ResetPlayersChestLamps(i);                 // reset the chest lamps
        PB_EnergyValue[i] = 25;                       // reset the energy value to 50K
        PB_ExBallsLit[i] = 0;                         // reset the lit extra balls
        PB_EjectMode[i] = 0;                          // reset the mode of the eject hole
        PB_LitChestLamps[Player-1] = 0;               // reset the number of lit chest lamps
        PB_Planet[i] = 0;}                            // reset reached planets
      InLock = 0;
      Player = 1;
      ExBalls = 0;
      Multiballs = 1;
      PB_MballState = 1;
      Bonus = 1;
      BonusMultiplier = 1;
      if (QuerySwitch(49) || QuerySwitch(50) || QuerySwitch(51)) {      // any drop target down?
        ActA_BankSol(4);}                             // reset it
      if (!QuerySwitch(44)) {                         // ramp in up state?
        ActA_BankSol(6);}                             // put it down
      ActivateSolenoid(0, 12);                        // turn off playfield GI
      PB_ChestMode = 20;                              // just play a chest pattern
      PB_ChestPatterns = (byte*)PB_GameStartPat;      // set chest lamps pattern
      PB_ChestLightHandler(100);                      // start player
      ActivateTimer(2400, 0, PB_GameStart) ;          // release a new ball (2 expected balls in the trunk)
      PlaySound(55, "0_ad.snd");                      // 'Pinbot circuits activated'
      ActivateSolenoid(0, 23);                        // enable flipper fingers
      ActivateSolenoid(0, 24);}
    break;
  case 8:                                             // high score reset
    digitalWrite(Blanking, LOW);                      // invoke the blanking
    break;
  case 16:                                            // outhole
    if (!BlockOuthole) {
      BlockOuthole = true;                            // block outhole until this ball has been processed
      ActivateTimer(200, 100, PB_AttractModeSW);}     // check again in 200ms
    break;
  case 46:
    if (PB_CloseVisorFlag) {
      //PlaySound(52, "0_f3.snd");
      PB_CloseVisorFlag = false;
      ReleaseSolenoid(13);}
    break;
  case 47:
    if (PB_OpenVisorFlag) {
      //PlaySound(52, "0_f3.snd");
      PB_OpenVisorFlag = false;
      ReleaseSolenoid(13);}
    break;
  case 72:
    Switch_Pressed = DummyProcess;
    RemoveBlinkLamp(1);                               // stop the blinking of the game over lamp
    ShowLampPatterns(0);                              // stop lamp animations
    PB_AttractDisplayCycle(0);                        // stop display animations
    LampPattern = NoLamps;                            // Turn off all lamps
    ReleaseAllSolenoids();
    if (APC_settings[DebugMode]) {                    // deactivate serial interface in debug mode
      Serial.end();}
    if (!QuerySwitch(73)) {                           // Up/Down switch pressed?
      WriteUpper("  TEST  MODE  ");
      WriteLower("              ");
      AppByte = 0;
      ActivateTimer(1000, 0, PB_Testmode);}
    else {
      Settings_Enter();}
    break;
  case 100:                                           // push ball in trunk
    if (QuerySwitch(16)) {                            // outhole switch still active?
      if (QuerySwitch(17) && QuerySwitch(18)) {       // all balls found? - only possible in 3Mball mode
        InLock = 0;}
      ActA_BankSol(1);                                // use outhole kicker
      ActivateTimer(1000, 100, PB_AttractModeSW);}    // check again in 500ms
    else {
      if (!game_settings[PB_Multiballs] && QuerySwitch(17) && QuerySwitch(18)) { // all balls found in 2Mball mode
        InLock = 0;}                                  // stop blocking new games
      BlockOuthole = false;}
    break;}}

void PB_GameStart(byte Dummy) {
  UNUSED(Dummy);
  PB_NewBall(2);
  ReleaseSolenoid(12);}                                // turn playfield GI back on

void AddPlayerSW(byte Switch) {
  if (Switch == 3) {
    PB_AddPlayer();}}

void PB_CheckForLockedBalls(byte Dummy) {             // check if balls are locked and release them
  UNUSED(Dummy);
  if (QuerySwitch(38)) {                              // for the single eject hole
    ActA_BankSol(3);}
  if (QuerySwitch(25) || QuerySwitch(26)) {           // for the eyes
    if (QuerySwitch(47)) {                            // visor is open
      if (QuerySwitch(25)) {                          // left eye
        ActA_BankSol(7);}                             // eject ball
      else {                                          // right eye
        ActA_BankSol(8);}}                            // eject ball
    else {                                            // visor is not open
      ActivateSolenoid(0, 13);                        // activate visor motor
      ActivateTimer(2000, 0, PB_OpenVisor);}}         // ignore the visor switch for 2 seconds
  else {                                              // no balls in lock
    if (!QuerySwitch(46)) {                               // visor not closed
      ActivateSolenoid(0, 13);                        // activate visor motor
      PlaySound(52, "0_f1.snd");
      ActivateTimer(2000, 0, PB_CloseVisor);}}}       // ignore the visor switch for 2 seconds

void PB_AddPlayer() {
  if ((NoPlayers < 4) && (Ball == 1)) {               // if actual number of players < 4
    NoPlayers++;                                      // add a player
    Points[NoPlayers] = 0;                            // delete the points of the new player
    ShowPoints(NoPlayers);}}                          // and show them

void PB_NewBall(byte Balls) {                         // release ball (Balls = expected balls on ramp)
  ShowAllPoints(0);
  if (game_settings[PB_Multiballs]) {                 // 3 ball multiball selected?
    PB_SolarValue = 0;                                // reset jackpot
    PB_SkillMultiplier = 1;}
  else {                                              // 2 ball multiball selected
    if (Balls < 10) {                                 // is it an extra ball?
      PB_SkillMultiplier = 0;}                        // no extra ball -> reset skill shot multiplier
    else {                                            // it's an extra ball
      Balls -= 10;}}                                  // restore balls value
  PlayMusic(50, "1_94.snd");                          // play non looping part of music track
  QueueNextMusic("1_94L.snd");                        // queue looping part as next music to be played}
  Bonus = 1;
  BonusMultiplier = 1;                                // reset bonus multiplier
  for (byte i=0; i<4; i++) {                          // turn off the corresponding lamps
    TurnOffLamp(9+i);}
  *(DisplayUpper+16) = LeftCredit[32 + 2 * Ball];     // show current ball in left credit
  BlinkScore(1);                                      // turn on score blinking
  PB_ClearChest();                                    // turn off chest lamps
  if (PB_Chest_Status[Player] > 100 && PB_MballState != 3) {  // > 100 means visor has to be open
    PB_Chest_Status[Player] = PB_Chest_Status[Player] - 100; // use it as a counter for opened visors
    PB_LampsToLight = 1;
    PB_ChestMode = 0;                                 // indicate an open visor
    if (!QuerySwitch(47)) {                           // visor not already open?
      PB_OpenVisorFlag = true;
      ActivateSolenoid(0, 13);}                       // open visor
    PB_EyeBlink(1);
    PB_ChestPatterns = (byte*)PB_WalkingLines;        // set chest lamps pattern
    PB_ChestLightHandler(100);}                       // start player
  else {
    if (!QuerySwitch(46)) {                           // visor not already closed?
      PlaySound(52, "0_f1.snd");
      PB_CloseVisorFlag = true;
      ActivateSolenoid(0, 13);}                       // close visor
    if (PB_LitChestLamps[Player-1]) {                 // chest lamps lit?
      if (PB_LitChestLamps[Player-1] > 100) {         // chest lamps have been lit but visor was closed
        PB_ChestMode = 1;                             // visor can still be opened with one hit
        PB_LitChestLamps[Player-1] -= 100;}           // restore correct value
      else {
        PB_ChestMode = 12;                            // indicate that the visor can not be opened with one hit
        PB_ChestPatterns = (byte*)PB_RandomChestPat;}}   // set chest lamps pattern
    else {
      PB_ChestMode = 1;}                              // indicate that the visor can be opened with one hit
    PB_ChestLightHandler(100);}                       // start chest animation
  if (PB_Chest_Status[Player] > 2) {                  // visor has been open more than 2 times
    PB_LampsToLight = 1;}                             // TODO change according to difficulty setting
  else {
    PB_LampsToLight = 2;}
  for (byte i=0; i<4; i++) {                          // restore extra ball lamps
    if (i<PB_ExBallsLit[Player]){
      TurnOnLamp(PB_ExBallLamps[i]);}
    else {
      TurnOffLamp(PB_ExBallLamps[i]);}}
  PB_HandleEjectHole(10);                             // restore eject hole lamps
  PB_DropBlinkLamp = 41;
  PB_CycleDropLights(1);                              // start the blinking drop target lights
  if (PB_Planet[Player] < game_settings[PB_ReachPlanet]+1) {  // target planet not reached yet?
    AddBlinkLamp(19+game_settings[PB_ReachPlanet],100);}    // let target planet blink
  byte Planets = PB_Planet[Player];
  if (Planets > 10) {                                 // sun already reached?
    Planets = Planets - 10;}
  if (Planets == 10) {                                // sun reached for the 2nd time?
    Planets = 0;}
  for (byte i=0; i<9; i++) {                          // update planets
    if (Planets > i) {
      TurnOnLamp(19+i);}
    else {
      TurnOffLamp(19+i);}}
  PB_GiveBall(Balls);}

void PB_PutBallInTrunk(byte Dummy) {
  UNUSED(Dummy);
  if (!C_BankActive) {
    ActivateSolenoid(game_settings[PB_BallEjectStrength], 1);}
  else {
    ActivateTimer(100, 0, PB_PutBallInTrunk);}}

void PB_GiveBall(byte Balls) {
  if (!game_settings[PB_Multiballs]) {                // only for 2 ball Multiball option
    if (PB_SkillMultiplier < 10) {
      PB_SkillMultiplier++;
      if (PB_SkillMultiplier == 10) {
        PlaySound(58, "0_af.snd");                    // 'million activated'
        PlayFlashSequence((byte*) PB_OpenVisorSeq);}}
    else {
      PB_SkillMultiplier = 1;}
    WriteUpper2(" VORTEX   X   ");
    WriteLower2("              ");
    ShowNumber(15, PB_SkillMultiplier);               // show multiplier
    PB_ShowMessage(3);}
  if (game_settings[PB_BallSaver]) {                  // activate ball saver if enabled
    PB_BallSave = 1;}
  PB_SkillShot = true;                                // the first shot is a skill shot
  if (!QuerySwitch(20)) {                             // ball not yet in shooter lane?
    Switch_Released = DummyProcess;
    ActA_BankSol(2);                                  // release ball
    Switch_Pressed = PB_BallReleaseCheck;             // set switch check to enter game
    CheckReleaseTimer = ActivateTimer(3000, Balls-1, PB_CheckReleasedBall);} // start release watchdog
  else {                                              // ball already in shooter lane
    Switch_Released = PB_CheckShooterLaneSwitch;      //  wait for switch 20 to be released
    Switch_Pressed = PB_ResetBallWatchdog;}}

void PB_CheckShooterLaneSwitch(byte Switch) {
  if (Switch == 20) {                                 // shooter lane switch released?
    Switch_Released = DummyProcess;
    PlaySound(53, "1_95.snd");
    if (PB_MballState == 4) {                         // 3 ball multiball running?
      Multiballs = 3;                                 // resume multiball
      AddBlinkLamp(35, 100);                          // start blinking of solar energy ramp
      PB_ShooterLaneWarning(0);}                      // turn off shooter lane warning
    if (!BallWatchdogTimer) {
      BallWatchdogTimer = ActivateTimer(30000, 0, PB_SearchBall);}}}

void PB_DisplayHooray(byte State) {
  const char Vortext[15] = {" VORTEX POWER "};
  const byte Pattern[24] = {25,0,137,0,161,0,97,0,69,0,21,0,25,0,137,0,161,0,97,0,69,0,21,0};
  static byte MyUpperDisplay[32];
  static byte MyLowerDisplay[32];
  static byte Count = 0;
  if ((State > 1) || ((State == 1) && !Count)) {
    if (State == 1) {
      for (byte i=0; i<32; i++){
        MyUpperDisplay[i] = 0;
        MyLowerDisplay[i] = 0;}
      PB_ShowMessage(254);                            // lock display
      *MyUpperDisplay = *DisplayUpper;                // copy credit display
      *(MyUpperDisplay+1) = *(DisplayUpper+1);
      *(MyUpperDisplay+16) = *(DisplayUpper+16);
      *(MyUpperDisplay+17) = *(DisplayUpper+17);
      *MyLowerDisplay = *DisplayLower;
      *(MyLowerDisplay+1) = *(DisplayLower+1);
      *(MyLowerDisplay+16) = *(DisplayLower+16);
      *(MyLowerDisplay+17) = *(DisplayLower+17);
      *(MyUpperDisplay+30) = DispPattern1[(int)((Vortext[0]-32)*2)];  // write 'V'
      *(MyUpperDisplay+31) = DispPattern1[(int)((Vortext[0]-32)*2+1)];
      DispRow1 = MyUpperDisplay;
      DispRow2 = MyLowerDisplay;
      ActivateTimer(50, 2, PB_DisplayHooray);}
    else if (State < 16) {                            // scroll text
      for (byte i=0; i<State; i++) {
        if (i < 7) {
          *(MyUpperDisplay+30-2*i) = DispPattern1[(int)((Vortext[State-2-i]-32)*2)];
          *(MyUpperDisplay+31-2*i) = DispPattern1[(int)((Vortext[State-2-i]-32)*2+1)];}
        else {                                        // skip the credit column
          *(MyUpperDisplay+28-2*i) = DispPattern1[(int)((Vortext[State-2-i]-32)*2)];
          *(MyUpperDisplay+29-2*i) = DispPattern1[(int)((Vortext[State-2-i]-32)*2+1)];}}
      State++;
      ActivateTimer(50, State, PB_DisplayHooray);}
    else if (State < 19) {
      for (byte i=0; i<State-14; i++) {
        *(MyLowerDisplay+30-2*i) = Pattern[2*Count];
        *(MyLowerDisplay+31-2*i) = Pattern[2*Count+1];}
      Count++;
      if (Count > 11) {
        Count = 0;
        if (State == 18) {
          if (PB_SkillMultiplier < 10) {
            *(MyLowerDisplay+20) = DispPattern2[32+2*PB_SkillMultiplier];
            *(MyLowerDisplay+21) = DispPattern2[33+2*PB_SkillMultiplier];}
          else {                                      // show 1M
            *(MyLowerDisplay+18) = DispPattern2[34];
            *(MyLowerDisplay+19) = DispPattern2[35];
            *(MyLowerDisplay+20) = DispPattern2[32];
            *(MyLowerDisplay+21) = DispPattern2[33];}}
        State++;}
      ActivateTimer(20, State, PB_DisplayHooray);}
    else if (State < 30) {                            // show animation of the zeros
      byte z = 5;
      if (PB_SkillMultiplier == 10) {
        z = 6;}
      for (byte i=0; i<z; i++) {
        *(MyLowerDisplay+30-2*i) = Pattern[2*Count];
        *(MyLowerDisplay+31-2*i) = Pattern[2*Count+1];}
      Count++;
      if (Count > 11) {
        Count = 0;
        State++;}
      ActivateTimer(20, State, PB_DisplayHooray);}
    else {
      Count = 0;
      SoundPriority = 50;
      PB_ShowMessage(255);                            // unlock display
      SwitchDisplay(1);                               // back to normal display
      RestoreMusicVolume(25);}}}

void PB_ResetBallWatchdog(byte Switch) {              // handle switches during ball release
  if ((Switch > 11)&&(Switch != 17)&&(Switch != 18)&&(Switch != 20)&&(Switch != 44)&&(Switch != 46)&&(Switch != 47)&&(Switch != 48)&&(Switch != 52)&&(Switch != 53)) { // playfield switch activated?
    PB_RampThunder(0);                                // stop thunder noise
    if (BallWatchdogTimer) {
      KillTimer(BallWatchdogTimer);}                  // stop watchdog
    if (PB_DropRamp&&(Switch != 45)&&(Switch != 49)&&(Switch != 50)&&(Switch != 51)) { // switch not close to the ramp?
      PB_DropRamp = false;                            // clear request
      ActA_BankSol(6);}                               // drop ramp
    if (PB_SkillShot) {                               // is this a skill shot?
      if (Switch != 20) {                             // no bouncing of the shooter lane switch?
        PB_SkillShot = false;                         // the next shot is not a skill shot any more
        byte c = 0;
        switch (Switch) {                             // was a skill shot target hit
        case 22:
          c = 20;
          PlayFlashSequence((byte*) PB_SkillShotFail);
          PlaySound(54, "1_91.snd");
          break;
        case 23:                                      // 100K hole hit
          c = 100;
          MusicVolume = 3;
          if (PB_SkillMultiplier == 10) {
            PlaySound(55, "0_fb.snd");}               // Hooray
          PlayFlashSequence((byte*) PB_OpenVisorSeq);
          ActivateTimer(10, 1, PB_DisplayHooray);
          PlaySound(53, "0_6e_1.snd");
          break;
        case 24:
          c = 5;
          PlayFlashSequence((byte*) PB_SkillShotFail);
          PlaySound(53, "1_91.snd");
          break;}
        if (!PB_ChestMode) {                          // visor is open
          if (InLock) {
            PlayMusic(50, "1_03L.snd");               // play 2nd lock music track
            QueueNextMusic("1_03L.snd");}
          else {
            PlayMusic(50, "1_02.snd");                // play open visor theme
            QueueNextMusic("1_02L.snd");}}
        else {                                        // visor is not open
          PlayMusic(50, "1_01L.snd");                 // play main theme
          QueueNextMusic("1_01L.snd");}               // track is looping so queue it also
        if (PB_SkillMultiplier < 10 && c!= 100) {     // no special display effect needed
          WriteUpper2(" VORTEX   X   ");
          WriteLower2("              ");
          ShowNumber(31, c * PB_SkillMultiplier * 1000);// show skill shot points
          ShowNumber(15, PB_SkillMultiplier);           // and multiplier
          PB_ShowMessage(3);}
        Points[Player] += c * 1000 * PB_SkillMultiplier;
        ShowPoints(Player);}}
    BallWatchdogTimer = ActivateTimer(30000, 0, PB_SearchBall);}
  PB_GameMain(Switch);}                               // process current switch

void PB_ShooterLaneWarning(byte State) {
	static byte Timer = 0;
	switch (State) {
	case 0:                                             // stop shooter lane warning
		if (Timer) {
			KillTimer(Timer);
			Timer = 0;}
		break;
	case 1:                                             // activate shooter lane warning
		if (!Timer) {																			// don't activate twice
			if (QuerySwitch(20)) {                          // ball still in shooter lane?
				Multiballs = 2;                               // stop jackpot as long as ball is in the shooter lane
				WriteUpper2(" LAUNCH BALL  ");
				WriteLower2("              ");
				ShowMessage(1);
				PlaySound(55, "0_6b.snd");                    // warning sound
				Switch_Released = PB_CheckShooterLaneSwitch;  // set mode to register when ball is shot
				Timer = ActivateTimer(1500, 2, PB_ShooterLaneWarning);}
			else {
				PB_SkillShot = false;}}
		break;
	case 2:                                             // every second
		Timer = 0;                                        // this case is called by timer
		if (QuerySwitch(20)) {                            // ball still in shooter lane?
			WriteUpper2(" LAUNCH BALL  ");
			WriteLower2("              ");
			ShowMessage(1);
			PlaySound(55, "0_6b.snd");                      // warning sound
			Timer = ActivateTimer(1500, 2, PB_ShooterLaneWarning);}}}

void PB_BallReleaseCheck(byte Switch) {               // handle switches during ball release
  if ((Switch > 11)&&(Switch != 17)&&(Switch != 18)&&(Switch != 19)&&(Switch != 44)&&(Switch != 46)&&(Switch != 47)) { // playfield switch activated?
    if (CheckReleaseTimer) {
      KillTimer(CheckReleaseTimer);
      CheckReleaseTimer = 0;}                         // stop watchdog
    Switch_Pressed = PB_ResetBallWatchdog;
    if (Switch == 20) {                               // ball is in the shooter lane
      Switch_Released = PB_CheckShooterLaneSwitch;}   // set mode to register when ball is shot
    else {
      if (!BallWatchdogTimer) {
        BallWatchdogTimer = ActivateTimer(30000, 0, PB_SearchBall);}}} // set switch mode to game
  PB_GameMain(Switch);}

void PB_CheckReleasedBall(byte Balls) {               // ball release watchdog
  CheckReleaseTimer = 0;
  BlinkScore(0);                                      // stop score blinking
  WriteUpper("WAITINGFORBALL");                       // indicate a problem
  WriteLower("              ");
  if (Balls == 10) {                                  // indicating a previous trunk error
    WriteUpper("              ");
    WriteLower("              ");
    ShowAllPoints(0);
    BlinkScore(1);                                    // turn on score blinking
    ActA_BankSol(2);}
  byte c = PB_CountBallsInTrunk();
  if (c == Balls) {                                   // expected number of balls in trunk
    WriteUpper("  BALL MISSING");
    if (QuerySwitch(16)) {                            // outhole switch still active?
      ActA_BankSol(1);}}                              // shove the ball into the trunk
  else {                                              //
    if (c == 5) {                                     // balls not settled
      WriteLower(" TRUNK  ERROR ");
      Balls = 10;}
    else {
      if ((c > Balls) || !c) {                        // more balls in trunk than expected or none at all
        WriteUpper("              ");
        WriteLower("              ");
        ShowAllPoints(0);
        BlinkScore(1);                                // turn on score blinking
        ActA_BankSol(2);}}}                           // release again
  CheckReleaseTimer = ActivateTimer(5000, Balls, PB_CheckReleasedBall);}

byte PB_CountBallsInTrunk() {
  byte Balls = 0;
  for (byte i=0; i<2; i++) {                          // check how many balls are on the ball ramp
    if (QuerySwitch(17+i)) {
      if (Balls < i) {
        return 5;}                                    // send warning
      Balls++;}}
  return Balls;}

byte PB_SearchBallCycle(byte Counter) {
  WriteUpper2("  BALL  SEARCH");
  WriteLower2("              ");
  ShowMessage(2);
  ActivateSolenoid(0, PB_BallSearchCoils[Counter]);   // fire coil to get ball free
  if (PB_BallSearchCoils[Counter] == 5) {             // ramp raise?
    PB_DropRamp = true;}                              // set flag to drop ramp
  if (PB_BallSearchCoils[Counter] == 6) {             // ramp down?
    PB_DropRamp = false;}                             // clear flag to drop ramp
  Counter++;
//  if (Counter == 9) {                                 // all coils fired?
//    Counter = 0;}                                     // start again
  if (QuerySwitch(46) && !QuerySolenoid(13)) {        // visor closed and motor not active?
    ActivateSolenoid(0, 13);                          // open it enough to deactivate switch 46
    ActivateTimer(2000, 0, PB_CloseVisor);}           // and prepare to close it again
  return(Counter);}

void PB_SearchBall(byte Counter) {                    // ball watchdog timer has run out
  BallWatchdogTimer = 0;
  switch (Counter) {
  case 7:                                             // PB_SearchBallCycle already completed?
    if (game_settings[PB_Multiballs]) {               // 3 ball multiball selected?
      switch (PB_MballState) {
      case 1:                                         // 1 ball in play -> possible double drain has occured
        WriteUpper2("WAITING  FOR  ");
        WriteLower2("         BALL ");
        ShowMessage(5);
        PlaySound(51, "0_6f.snd");
        Counter = 20;
        break;
      default:                                        // in all other cases just rerun ball search cycle
        Counter = 0;
        break;}}
    else {
      Counter = 0;}
    BallWatchdogTimer = ActivateTimer(4000, Counter, PB_SearchBall);
    break;
  case 20:
    WriteUpper2(" DO NOT LAUNCH");
    WriteLower2("         BALL ");
    ShowMessage(3);
    PlaySound(51, "0_6f.snd");
    ActA_BankSol(2);                              // release ball
    BallWatchdogTimer = ActivateTimer(2000, Counter+1, PB_SearchBall);
    break;
  case 21:
    PlaySound(51, "0_6f.snd");
    if (PB_CountBallsInTrunk() == 2) {
      WriteUpper2("  BALL DRAINED");
      WriteLower2("              ");
      ShowMessage(2);
      ActivateTimer(2000, 2, PB_BallEnd);}
    else {
      WriteUpper2("  BALL MISSING");
      WriteLower2("              ");
      ShowMessage(5);}
    break;
  default:                                            // initial call and ball search
    if (!QuerySwitch(10) && !QuerySwitch(11) && !QuerySwitch(20)) { // if ball is waiting to be launched or any flipper finger up
      if (QuerySwitch(16)) {                          // ball in outhole?
        BlockOuthole = false;
        ActivateTimer(1000, 0, PB_ClearOuthole);}
      else if (QuerySwitch(38)) {                     // ball in eject hole?
        PB_HandleEjectHole(3);}                       // release it
      else {
        byte c = PB_CountBallsInTrunk();              // recount all balls
        if (c == 5) {                                 // balls have not settled yet
          WriteUpper("  BALL  STUCK ");
          BallWatchdogTimer = ActivateTimer(1000, 0, PB_SearchBall);} // and try again in 1s
        else {
          if (game_settings[PB_Multiballs]) {         // 3 ball multiball selected?
            switch (PB_MballState) {
            case 1:                                   // one ball in play
              PB_CountBallsInLock();
              if (InLock) {                           // number of locked balls not as expected
                PB_HandleLock(0);}                    // and call it
              else {
                Counter = PB_SearchBallCycle(Counter); // fire coils to search ball
                BallWatchdogTimer = ActivateTimer(1000, Counter, PB_SearchBall);}
              break;
            case 2:                                   // one ball in lock
            case 6:
              PB_CountBallsInLock();
              if (InLock != 1) {                      // number of locked balls not as expected
                PB_HandleLock(0);}                    // and call it
              else {
                Counter = PB_SearchBallCycle(Counter); // fire coils to search ball
                BallWatchdogTimer = ActivateTimer(1000, Counter, PB_SearchBall);}
              break;
            case 3:                                   // two balls in lock
              PB_CountBallsInLock();
              if (InLock != 2) {                      // number of locked balls not as expected
                PB_HandleLock(0);}                    // and call it
              else if (c > 0) {                       // unexpected ball in trunk
                PB_BallEnd(c);}
              else {
                Counter = PB_SearchBallCycle(Counter); // fire coils to search ball
                BallWatchdogTimer = ActivateTimer(1000, Counter, PB_SearchBall);}
              break;
            default:
              Counter = PB_SearchBallCycle(Counter);  // fire coils to search ball
              BallWatchdogTimer = ActivateTimer(1000, Counter, PB_SearchBall);
              break;}}
          else {                                      // 2 ball multiball selected
            if (c == 2) {                             // found 2 balls in trunk?
              if (BlockOuthole) {                     // is the outhole blocked
                PB_BallEnd(0);}                       // then it was probably a ball loss gone wrong
              else {
                ActivateTimer(1000, 2, PB_NewBall);}} // otherwise try it with a new ball
            else {
              byte c2 = 0;
              for (byte i=0; i<2; i++) {              // count balls in lock
                if (QuerySwitch(25+i)) {
                  c2++;}}
              if (c2 > InLock) {                      // more locked balls found than expected?
                PB_HandleLock(0);                     // lock them
                BallWatchdogTimer = ActivateTimer(30000, 0, PB_SearchBall);}
              else {
                Counter = PB_SearchBallCycle(Counter); // fire coils to search ball
                BallWatchdogTimer = ActivateTimer(1000, Counter, PB_SearchBall);}}}}}} // come again in 1s if no switch is activated
    else {
      BallWatchdogTimer = ActivateTimer(30000, 0, PB_SearchBall);}}}

void PB_OpenVisor(byte Dummy) {
  UNUSED(Dummy);
  PB_OpenVisorFlag = true;}                           // set flag to stop visor motor when open

void PB_CloseVisor(byte State) {
  if (State) {
    PlaySound(52, "0_f1.snd");                        // moving visor sound
    ActivateSolenoid(0, 13);                          // activate visor motor
    ActivateTimer(2000, 0, PB_CloseVisor);}           // come back to set PB_CloseVisorFlag
  else {
    PB_CloseVisorFlag = true;}}                       // set flag to stop visor motor when closed

void PB_CountBallsInLock() {
  InLock = 0;
  for (byte i=0; i<2; i++) {                          // check how many balls are in the eyes
    if (QuerySwitch(25+i)) {
      InLock++;}}}

void PB_ClearOuthole(byte State) {
  static byte Trunk;
  if (game_settings[PB_Multiballs]) {                 // 3 ball multiball selected?
    switch (State) {
    case 0:                                           // inital call
      if (QuerySwitch(16)) {                          // outhole switch still active?
        Trunk = PB_CountBallsInTrunk();
        switch (PB_MballState) {
        case 1:                                       // one ball in play
          if (Trunk == 2) {                           // 2 balls expected to be in trunk
            ActivateTimer(10, 5, PB_ClearOuthole);}   // proceed to next state
          else {                                      // wrong ball count
            ActivateTimer(1000, 1, PB_ClearOuthole);}
          break;
        case 2:                                       // one ball in lock
        case 5:                                       // two balls in game but none in lock
        case 6:                                       // one ball in lock after multiball
          if (Trunk == 1) {                           // 1 ball expected to be in trunk
            ActivateTimer(10, 5, PB_ClearOuthole);}   // proceed to next state
          else {                                      // wrong ball count
            ActivateTimer(1000, 1, PB_ClearOuthole);}
          break;
        case 3:                                       // two balls in lock
        case 4:                                       // 3 ball multiball
          if (!Trunk) {                               // 0 balls expected to be in trunk
            ActivateTimer(10, 5, PB_ClearOuthole);}   // proceed to next state
          else {                                      // wrong ball count
            ActivateTimer(1000, 1, PB_ClearOuthole);}
          break;}}
      else {                                          // outhole free
        BlockOuthole = false;}
      break;
    case 1:                                           // trunk count doesn't match
      Trunk = PB_CountBallsInTrunk();
      PB_CountBallsInLock();
      switch (PB_MballState) {
      case 1:                                         // one ball in play
        if (Trunk == 2) {                             // 2 balls expected to be in trunk
          ActivateTimer(10, 5, PB_ClearOuthole);}     // proceed to next state
        else {                                        // wrong ball count
          if (!InLock) {
            PB_MballState = 5;
            ActivateTimer(10, 0, PB_ClearOuthole);}
          else if (InLock == 1) {
            PB_MballState = 6;
            ActivateTimer(10, 0, PB_ClearOuthole);}
          else {
            PB_MballState = 3;
            ActivateTimer(10, 0, PB_ClearOuthole);}}
        break;
      case 2:                                         // one ball in lock
      case 5:                                         // 2 balls still in game
      case 6:                                         // one ball re-locked
        if (Trunk == 1) {                             // 1 ball expected to be in trunk
          ActivateTimer(10, 5, PB_ClearOuthole);}     // proceed to next state
        else if (Trunk == 2){                         // ball may have jumped through outhole
          if (!QuerySwitch(16)) {                     // no ball in outhole?
            ActivateTimer(1000, 10, PB_ClearOuthole);}  // then it's confirmed
          else {
            PB_MballState = 1;
            ActivateTimer(10, 0, PB_ClearOuthole);}}
        break;
      case 3:                                         // 2 balls in lock
      case 4:                                         // 3 ball multiball
        if (!Trunk) {                                 // trunk is supposed to be empty
          ActivateTimer(10, 5, PB_ClearOuthole);}     // proceed to next state
        else if (Trunk == 1){                         // ball may have jumped through outhole
          if (!QuerySwitch(16)) {                     // no ball in outhole?
            ActivateTimer(1000, 10, PB_ClearOuthole);}}}  // then it's confirmed
      break;
    case 5:                                           // ball count OK, put ball in trunk
      if (!C_BankActive) {
        ActivateSolenoid(game_settings[PB_BallEjectStrength], 1); // put ball in trunk
        ActivateTimer(1000, 10, PB_ClearOuthole);}
      else {
        ActivateTimer(1000, 5, PB_ClearOuthole);}     // try again
      break;
    case 10:                                          // ball was kicked in outhole
      if (QuerySwitch(16)) {                          // ball still in outhole?
        if (PB_MballState == 4 || PB_MballState == 5) { // probably a double drain
          PB_BallEnd(1);                              // call ball end twice
          BlockOuthole = true;}                       // block outhole again
        ActA_BankSol(1);                              // make the coil a bit stronger
        ActivateTimer(2000, 10, PB_ClearOuthole);}    // and come back in 2s
      else {
        PB_BallEnd(Trunk+1);}}}
  else {                                              // 2 ball multiball selected
    switch (State) {
    case 0:
      if (QuerySwitch(16)) {                          // outhole switch still active?
        if (!C_BankActive) {                          // correct solenoid bank active?
          ActivateSolenoid(30, 1);                    // put ball in trunk
          ActivateTimer(2000, 1, PB_ClearOuthole);}   // come back to check
        else {
          ActivateTimer(500, 0, PB_ClearOuthole);}}   // wait for A-bank to be active
      else {                                          // outhole free
        BlockOuthole = false;}
      break;
    case 1:                                           // check if ball is in trunk
    case 2:
    case 3:
      Trunk = PB_CountBallsInTrunk();
      if ((Trunk == 5)||(Trunk < 3-Multiballs-InLock)) {  // something's wrong in the trunk
        InLock = 0;
        if (Multiballs == 1) {
          for (byte i=0; i<2; i++) {                  // check how many balls are in the eyes
            if (QuerySwitch(25+i)) {
              InLock++;}}}
        WriteLower(" BALL   ERROR ");
        if (QuerySwitch(16)) {                        // ball still in outhole?
          ActA_BankSol(1);                            // make the coil a bit stronger
          ActivateTimer(2000, 1, PB_ClearOuthole);}   // and come back in 2s
        else {
          State++;
          ActivateTimer(1000, State, PB_ClearOuthole);}}   // if not try again in 1s
      else {
        ActivateTimer(100, Trunk, PB_BallEnd);}
      break;
    case 4:                                           // ball count still wrong but proceeding anyway
      ActivateTimer(100, Trunk, PB_BallEnd);}}}

void PB_MultiballThunder(byte State) {
  if (State < 8) {
    PlaySound(54, "0_d7.snd");
    State++;
    ActivateTimer(500, State, PB_MultiballThunder);}
  else if (State < 9) {
    MusicVolume = 0;
    PlaySound(54, "0_fb.snd");
    ActivateTimer(3300, 9, PB_MultiballThunder);
    ActivateTimer(6000, 10, PB_MultiballThunder);}
  else if (State < 10) {
    PlayMusic(50, "1_04.snd");                        // play non looping part of music track
    QueueNextMusic("1_04L.snd");}                     // queue looping part as next music to be played
  else {
    if (Multiballs == 3 && PB_SolarValue == 1000) {   // 1M jackpot in 3 ball multiball mode?
      PlaySound(58, "0_af.snd");}                     // 'million activated'
    else {
      StopPlayingSound();}}}

void PB_RampThunder(byte State) {                     // State = 0 -> Stop
	static byte Timer = 0;
	switch (State) {
	case 0:
		if (Timer) {
			RestoreMusicVolume(25);
			KillTimer(Timer);
			Timer = 0;}
		break;
	case 8:                                             // play thunder 7 times
		RestoreMusicVolume(25);
		Timer = 0;
		break;
	case 1:																							// initial call
		if (Timer) {
			KillTimer(Timer);} 															// @suppress("No break at end of case")
	default:
		PlaySound(51, "0_d7.snd");
		Timer = ActivateTimer(1500, State+1, PB_RampThunder);
		break;}}

void PB_PlayEjectHoleSounds(byte Number) {
  PlaySound(51, "1_83.snd");
  Number--;
  if (Number) {
    ActivateTimer(400, Number, PB_PlayEjectHoleSounds);}
  else {
    PlaySound(51, "0_e9.snd");}}

void PB_EnergyRestoreLamps(byte Dummy) {
  UNUSED(Dummy);
  RestoreMusicVolume(10);
  LampPattern = LampColumns;}

void PB_GameMain(byte Switch) {
  static bool RampSound;
  switch(Switch) {
  case 1:
  case 2:
  case 7:
  case 9:
    WriteUpper(" TILT  WARNING");
    ActivateTimer(3000, 0, ShowAllPoints);
    break;
  case 3:
    if (Ball == 1) {
      PB_AddPlayer();}
    break;
  case 4:
  case 5:
  case 6:
    WriteUpper(" FREE   GAME  ");
    ActivateTimer(3000, 0, ShowAllPoints);
    break;
  case 8:                                             // high score reset
    LampPattern = LampColumns;
//    Serial.print("PB_CycleDropLights = ");            // print address reference table
//    Serial.println((unsigned int)&PB_CycleDropLights);
//    Serial.print("PB_AttractDisplayCycle = ");
//    Serial.println((unsigned int)&PB_AttractDisplayCycle);
//    Serial.print("PB_AttractLampCycle = ");
//    Serial.println((unsigned int)&PB_AttractLampCycle);
//    Serial.print("ScrollUpper = ");
//    Serial.println((unsigned int)&ScrollUpper);
//    Serial.print("ScrollLower = ");
//    Serial.println((unsigned int)&ScrollLower);
//    Serial.print("ScrollLower2 = ");
//    Serial.println((unsigned int)&ScrollLower2);
//    Serial.print("PB_SearchBall = ");
//    Serial.println((unsigned int)&PB_SearchBall);
//    Serial.print("PB_ChestLightHandler = ");
//    Serial.println((unsigned int)&PB_ChestLightHandler);
//    Serial.print("BlinkScore = ");
//    Serial.println((unsigned int)&BlinkScore);
//    Serial.print("BlinkLamps = ");
//    Serial.println((unsigned int)&BlinkLamps);
//    Serial.print("ShowMessage = ");
//    Serial.println((unsigned int)&ShowMessage);
//    Serial.print("PB_CountBonus = ");
//    Serial.println((unsigned int)&PB_CountBonus);
//    Serial.print("PB_AfterExBallRelease = ");
//    Serial.println((unsigned int)&PB_AfterExBallRelease);
//    Serial.print("PB_BallEnd = ");
//    Serial.println((unsigned int)&PB_BallEnd);
//    Serial.print("ReleaseSolenoid = ");
//    Serial.println((unsigned int)&ReleaseSolenoid);
//    Serial.print("ActSolenoid = ");
//    Serial.println((unsigned int)&ActSolenoid);
//    Serial.print("ShowLampPatterns = ");
//    Serial.println((unsigned int)&ShowLampPatterns);
//    Serial.print("StrobeLights = ");
//    Serial.println((unsigned int)&StrobeLights);
//    Serial.print("SelectSettings = ");
//    Serial.println((unsigned int)&SelectSettings);
//    Serial.print("PB_OpenVisor = ");
//    Serial.println((unsigned int)&PB_OpenVisor);
//    Serial.print("PB_CloseVisor = ");
//    Serial.println((unsigned int)&PB_CloseVisor);
//    Serial.print("PB_StartChestPattern = ");
//    Serial.println((unsigned int)&PB_StartChestPattern);
//    Serial.print("PB_CheckReleasedBall = ");
//    Serial.println((unsigned int)&PB_CheckReleasedBall);
//    Serial.print("PB_ClearOuthole = ");
//    Serial.println((unsigned int)&PB_ClearOuthole);
//    Serial.print("PB_NewBall = ");
//    Serial.println((unsigned int)&PB_NewBall);
//    Serial.print("ShowAllPoints = ");
//    Serial.println((unsigned int)&ShowAllPoints);
//    Serial.print("PB_HandleLock = ");
//    Serial.println((unsigned int)&PB_HandleLock);
//    Serial.print("PB_ClearEjectHole = ");
//    Serial.println((unsigned int)&PB_ClearEjectHole);
//    Serial.print("PB_HandleDropTargets = ");
//    Serial.println((unsigned int)&PB_HandleDropTargets);
//    Serial.print("PB_ReopenVisor = ");
//    Serial.println((unsigned int)&PB_ReopenVisor);
//    Serial.print("PB_ClearOutLock = ");
//    Serial.println((unsigned int)&PB_ClearOutLock);
//    Serial.print("DelaySolenoid = ");
//    Serial.println((unsigned int)&DelaySolenoid);
//    Serial.print("InLock = ");
//    Serial.println((unsigned int)InLock);
//    Serial.print("Multiballs = ");
//    Serial.println((unsigned int)Multiballs);
//    Serial.print("PB_ChestMode = ");
//    Serial.println((unsigned int)PB_ChestMode);
//    byte c=0;
//    byte i=1;
//    while (c<ActiveTimers) {                          // list all active timers
//      if (TimerEvent[i]) {
//        c++;
//        Serial.print("T");
//        Serial.print(i);
//        Serial.print("= ");
//        Serial.print(TimerArgument[i]);
//        Serial.print(" ");
//        Serial.println((unsigned int)TimerEvent[i]);}
//      i++;}
//    SwitchDisplay(1);
//    digitalWrite(Blanking, LOW);                      // invoke the blanking
    break;
  case 10:                                            // left lane change
    PB_MoveExBallLamps(0);
    PB_BallSave = 0;                                  // ball saver is off when flippers are used
    break;
  case 11:                                            // right lane change
    PB_MoveExBallLamps(1);
    PB_BallSave = 0;                                  // ball saver is off when flippers are used
    break;
  case 12:                                            // left outlane
    PlaySound(51, "1_a5.snd");
    if (PB_BallSave) {
      PB_BallSave = 2;                                // trigger the ball saver
      AddBlinkLamp(33, 250);}
    else {
      Points[Player] += 20000;
      ShowPoints(Player);
      PB_AddBonus(3);
      if (QueryLamp(49)) {
        TurnOffLamp(49);
        PB_ExBallsLit[Player]--;
        PB_GiveExBall();}}
    break;
  case 13:                                            // left inlane
    PlaySound(51, "1_8b.snd");
    Points[Player] += 5000;
    ShowPoints(Player);
    PB_AddBonus(1);
    TurnOnLamp(18);
    if (QueryLamp(50)) {
      TurnOffLamp(50);
      PB_ExBallsLit[Player]--;
      PB_GiveExBall();}
    break;
  case 14:                                            // right inlane
    PlaySound(51, "1_8b.snd");
    Points[Player] += 5000;
    ShowPoints(Player);
    PB_AddBonus(1);
    if (QueryLamp(58)) {
      TurnOffLamp(58);
      PB_ExBallsLit[Player]--;
      PB_GiveExBall();}
    PB_HandleEjectHole(11);                           // proceed to next eject hole state
    break;
  case 15:                                            // right outlane
    PlaySound(51, "1_a5.snd");
    if (PB_BallSave) {
      PB_BallSave = 2;                                // trigger the ball saver
      AddBlinkLamp(33, 250);}
    else {
      Points[Player] += 20000;
      ShowPoints(Player);
      PB_AddBonus(3);
      if (QueryLamp(57)) {
        TurnOffLamp(57);
        PB_ExBallsLit[Player]--;
        PB_GiveExBall();}}
    break;
  case 16:                                            // outhole
    if (!BlockOuthole) {
      BlockOuthole = true;                            // block outhole until this ball has been processed
      ActivateTimer(200, 0, PB_ClearOuthole);}        // check again in 200ms
    break;
  case 19:                                            // advance planet
    if (PB_SpecialLit) {                              // special lit?
      PB_SpecialLit = false;
      MusicVolume = 4;
      PlaySound(53, "1_ab.snd");
      PlayFlashSequence((byte*) PB_OpenVisorSeq);     // play flasher sequence
      ActC_BankSol(1);                                // use knocker
      ActivateTimer(4300, 0, PB_AdvancePlanet);}
    else if (QueryLamp(18)) {                         // advance planet lit?
      TurnOffLamp(18);
      PB_AddBonus(1);
      PB_AdvancePlanet(1);}
    else {                                            // unlit
      Points[Player] += 5000;
      PlaySound(51, "1_96.snd");}
    break;
  case 20:                                            // shooter lane
    if (!PB_SkillShot) {
      if (!game_settings[PB_Multiballs] && PB_SkillMultiplier < 10) {
        PB_SkillMultiplier++;
        WriteUpper2(" VORTEX   X   ");
        WriteLower2("              ");
        ShowNumber(15, PB_SkillMultiplier);           // show multiplier
        PB_ShowMessage(3);
        if (PB_SkillMultiplier == 10) {
          PlaySound(55, "0_af.snd");                  // "Million activated"
          PlayFlashSequence((byte*) PB_OpenVisorSeq);}}
      else {
        PB_SkillMultiplier = 1;
        if (PB_MballState == 4) {                     // 3 ball multiball running?
          RemoveBlinkLamp(35);                        // solar energy lamp
          ActivateTimer(200, 1, PB_ShooterLaneWarning);}} // turn on shooter lane warning
      PB_SkillShot = true;}                           // the first shot is a skill shot
    break;
  case 25:                                            // left eye
  case 26:                                            // right eye
    if (!PB_IgnoreLock) {
      PB_IgnoreLock = true;
      Points[Player] += 10000;
      PB_AddBonus(1);
      ActivateTimer(1000, 0, PB_HandleLock);}         // handle locked balls after 1s
    break;
  case 28:                                            // chest
  case 29:
  case 30:
  case 31:
  case 32:
  case 33:
  case 34:
  case 35:
  case 36:
  case 37:
    if (PB_ChestMode) {                               // visor closed?
      PB_ChestLightHandler(0);                        // stop chest animation
      AppByte = Switch-27;                            // buffer the switch number
      if (Switch > 32) {                              // is it a row?
        AppByte = 16 - AppByte;}                      // turn the rows upside down
      if (PB_ChestMode < 11) {                        // visor can be opened with one row / column hit
        if (AppByte == PB_ChestMode) {                // correct row / column hit?
          PB_ChestMode = 0;                           // indicate an open visor
          PB_AddBonus(1);
          PB_OpenVisorProc(0);}                       // open visor
        else {                                        // incorrect row / column hit
          PB_ChestMode = Switch-17;                   // Store row / column hit
          PB_SetChestLamps(Switch-28);                // add the lamps for the hit row / column in PB_ChestLamp
          PB_ClearChest();                            // turn off chest lamps
          PB_ChestLightHandler(1);}}                  // call effect routine
      else {                                          // the cumbersome way to open the visor
        PB_ChestMode = Switch-17;                     // Store row / column hit
        PB_SetChestLamps(Switch-28);                  // add the lamps for the hit row / column in PB_ChestLamp
        if (PB_LitChestLamps[Player-1] == 25) {       // complete chest lit?
          PB_OpenVisorProc(0);}                       // open visor
        else {
          PB_ClearChest();                            // turn off chest lamps
          PB_ChestLightHandler(1);}}}                 // call effect routine
    else {                                            // visor open
      PB_SetChestLamps(Switch-28);}                   // add the lamps for the hit row / column in PB_ChestLamp
    break;
  case 38:                                            // eject hole
      PB_HandleEjectHole(1);
    break;
  case 39:                                            // solar ramp exit
    uint16_t Buffer;
    PB_AddBonus(1);
    RampSound = false;
    MusicVolume = 3;                                  // reduce music volume
    if (Multiballs == 3 || PB_SolarValueTimer) {      // solar ramp lit
      if (game_settings[PB_Multiballs]) {             // 3 ball multiball mode?
        if (PB_SolarValue < 1000) {                   // jackpot < 1M?
          PB_SolarValue += 200;}                      // add 200K
        Buffer = PB_SolarValue;}
      else {                                          // 2 ball multiball mode?
        if (PB_SolarValueTimer) {
          KillTimer(PB_SolarValueTimer);
          PB_SolarValueTimer = 0;
          RemoveBlinkLamp(35);}                       // solar energy lamp
        ActivateTimer(2000,1,PB_EyeBlink);
        Buffer = PB_SolarValue;
        PB_SolarValue = 100;
        PB_ClearOutLock(0);}
      PlayFlashSequence((byte*) PB_OpenVisorSeq);
      PB_MultiballThunder(0);                         // play sound effects
      Points[Player] += PB_SolarValue * 1000;
      ShowPoints(Player);}
    else {                                            // solar ramp not lit
      PlaySound(51, "1_a9.snd");
      Points[Player] += 1000;
      ActivateTimer(1400, 1, PB_RampThunder);
      if (BonusMultiplier < 5) {                      // increase bonus multiplier
        TurnOnLamp(8+BonusMultiplier);                // turn on the corresponding lamp
        BonusMultiplier++;}
      if (PB_SolarValue < 5000) {
        PB_SolarValue += 50;
        if (PB_SolarValue > 5000) {
          PB_SolarValue = 5000;}}
      Buffer = PB_SolarValue;}
    if (Player < 3) {
      WriteLower2("SOLAR =       ");
      ShowNumber(31, Buffer*1000);}
    else {
      WriteUpper2("SOLAR =       ");
      ShowNumber(15, Buffer*1000);}
    break;
  case 40:                                            // ramp entrance
    if (RampSound) {
      RampSound = false;
      PlaySound(51, "1_a9.snd");}
    else {
      RampSound = true;
      Points[Player] += 10;
      PlaySound(51, "1_a8.snd");}
    break;
  case 45:                                            // score energy switch
    if (PB_EnergyActive) {
      Points[Player] += PB_EnergyValue[Player] * 2000;// score energy value
      WriteUpper2(" ENERGY VALUE ");
      WriteLower2("              ");
      ShowNumber(31, PB_EnergyValue[Player]*2000);
      PlaySound(55, "0_ca.snd");                      // 'Energy transferred'
//      ActivateTimer(1950, Argument, EventPointer)
//      QueueNextSound("0_46.snd");
      PlayFlashSequence((byte*) PB_ScoreEnergySeq);
      PatPointer = PB_EnergyPat;                      // set the pointer to the lamp pattern
      FlowRepeat = 7;                                 // set the repetitions
      ActivateTimer(1700, 0, PB_EnergyRestoreLamps) ;  // call this when the lamp pattern has run out
      ShowLampPatterns(1);                            // play the lamp pattern
      PB_ShowMessage(3);}
    PB_HandleEnergy(0);                               // turn off energy lamp and sounds
    break;
  case 46:                                            // visor closed
    if (PB_CloseVisorFlag) {
      PlaySound(52, "0_f3.snd");
      PB_CloseVisorFlag = false;
      ReleaseSolenoid(13);
      PB_EyeBlink(0);}                                // turn off eye blinking
    break;
  case 47:                                            // visor open
    if (PB_OpenVisorFlag) {
      PlaySound(52, "0_f3.snd");
      PB_OpenVisorFlag = false;
      ReleaseSolenoid(13);}
    break;
  case 49:                                            // drop targets
  case 50:
  case 51:
    if (!PB_DropWait) {
      PB_DropWait = true;
      PB_AddBonus(1);
      Points[Player] += 1000;
      ShowPoints(Player);
      ActivateTimer(200, Switch, PB_HandleDropTargets);}
    break;
  case 56:                                            // standup targets
  case 59:
  case 60:
    PlaySound(50, "1_8d.snd");
    Points[Player] += 10;
    break;
  case 65:                                            // lower jet bumper
    Points[Player] += 1000;
    ActivateSolenoid(0, 17);
    if (C_BankActive) {
      ActivateSolenoid(0, 6);}
    else {                                            // TODO add priority to ActA and ActC_bank commands
      ActC_BankSol(6);}
    if (PB_EnergyValue[Player] < 250) {
      PB_EnergyValue[Player]++;
      WriteUpper2(" ENERGY VALUE ");
      WriteLower2("              ");
      ShowNumber(31, PB_EnergyValue[Player] * 2000);
      PB_ShowMessage(3);}
    break;
  case 67:                                            // left jet bumper
    Points[Player] += 1000;
    ActivateSolenoid(0, 19);
    if (C_BankActive) {
      ActivateSolenoid(0, 6);}
    else {                                            // TODO add priority to ActA and ActC_bank commands
      ActC_BankSol(6);}
    if (PB_EnergyValue[Player] < 250) {
      PB_EnergyValue[Player]++;
      WriteUpper2(" ENERGY VALUE ");
      WriteLower2("              ");
      ShowNumber(31, PB_EnergyValue[Player] * 2000);
      PB_ShowMessage(3);}
    break;
  case 68:                                            // left slingshot
    PB_MoveExBallLamps(0);
    ActivateSolenoid(0, 20);
    ActC_BankSol(5);
    break;
  case 69:                                            // right slingshot
    PB_MoveExBallLamps(1);
    ActivateSolenoid(0, 21);
    ActC_BankSol(5);
    break;
  case 70:                                            // upper jet bumper
    Points[Player] += 1000;
    ActivateSolenoid(0, 22);
    if (C_BankActive) {
      ActivateSolenoid(0, 6);}
    else {                                            // TODO add priority to ActA and ActC_bank commands
      ActC_BankSol(6);}
    if (PB_EnergyValue[Player] < 250) {
      PB_EnergyValue[Player]++;
      WriteUpper2(" ENERGY VALUE ");
      WriteLower2("              ");
      ShowNumber(31, PB_EnergyValue[Player] * 2000);
      PB_ShowMessage(3);}
    break;}}

void PB_MoveExBallLamps(byte Direction) {
  if (PB_ExBallsLit[Player]) {
    if (Direction) {
      Direction = QueryLamp(57);
      for (byte c=0; c<3; c++) {
        if (QueryLamp(PB_ExBallLamps[3-c-1])) {
          TurnOnLamp(PB_ExBallLamps[3-c]);}
        else {
          TurnOffLamp(PB_ExBallLamps[3-c]);}}
      if (Direction) {
        TurnOnLamp(49);}
      else {
        TurnOffLamp(49);}}
    else {
      Direction = QueryLamp(49);
      for (byte c=0; c<3; c++) {
        if (QueryLamp(PB_ExBallLamps[c+1])) {
          TurnOnLamp(PB_ExBallLamps[c]);}
        else {
          TurnOffLamp(PB_ExBallLamps[c]);}}
      if (Direction) {
        TurnOnLamp(57);}
      else {
        TurnOffLamp(57);}}}}

void PB_AddExBall() {
  if (PB_ExBallsLit[Player] < 4) {
    PB_ExBallsLit[Player]++;
    byte c = 0;
    while (QueryLamp(PB_ExBallLamps[c])) {
      c++;}
    TurnOnLamp(PB_ExBallLamps[c]);}}

void PB_AfterExBallRelease(byte Event) {
  if (QuerySwitch(20)) {                              // ball still in the shooting lane?
    ActivateTimer(2000, Event, PB_AfterExBallRelease);}  // come back in2s
  else {                                              // ball has been shot
    RemoveBlinkLamp(33);
    if (ExBalls) {                                    // player still has an extra balls
      TurnOnLamp(33);}}}

void PB_GiveExBall() {
  ExBalls++;
  TurnOnLamp(33);}

void PB_AddBonus(byte BonusToAdd) {
  if (Bonus < 99) {
    Bonus = Bonus + BonusToAdd;
    if (Bonus > 99) {
      Bonus = 99;}
    if (Player < 3) {
      WriteLower2("BONUS =       ");
      ShowNumber(31, Bonus*1000);
      DispRow2 = DisplayLower2;}
    else {
      WriteUpper2("BONUS =       ");
      ShowNumber(15, Bonus*1000);
      DispRow1 = DisplayUpper2;}
    ShowMessage(2);}}

void PB_StartChestPattern(byte Dummy) {
  UNUSED(Dummy);
  LampPattern = LampColumns;
  PB_ChestLightHandler(100);}

void PB_VisorOpen(byte Dummy) {                       // Play sound and music when visor has opened
  UNUSED(Dummy);
  PB_ChestLightHandler(0);                            // stop chest animation
  PB_ChestPatterns = (byte*)PB_ExpandingSquares;
  PB_StartChestPattern(0);
  ActivateTimer(2600, 25, RestoreMusicVolume);        // restore music volume after sound has been played
  PlaySound(55, "0_db.snd");}                         // 'I am in your control'

void PB_BlinkGI(byte Number) {
  ActivateSolenoid(150, 12);
  Number--;
  if (Number) {
    ActivateTimer(700, Number, PB_BlinkGI);}}

void PB_OpenVisorProc(byte Dummy) {                   // measures to open the visor
  UNUSED(Dummy);
  PlaySound(52, "0_f1.snd");                          // moving visor sound
  ActivateTimer(3900, 0, PB_VisorOpen) ;              // call after sound
  MusicVolume = 4;                                    // reduce music volume
  PlayMusic(50, "1_02.snd");                          // change music
  QueueNextMusic("1_02L.snd");                        // queue looping part as next music to be played
  PB_ChestMode = 0;                                   // indicate that the visor is open
  PB_Chest_Status[Player]++;                          // increase the number of visor openings
  if (PB_Chest_Status[Player] == 2) {                 // visor opened two times?
    PB_AddExBall();}
  PB_LitChestLamps[Player-1] = 0;                     // reset the counter
  PB_ResetPlayersChestLamps(Player);                  // reset the stored lamps
  PB_ClearChest();                                    // turn off chest lamps
  PB_ChestPatterns = (byte*)PB_OpenVisorPat;          // request chest animation
  PB_StartChestPattern(0);                            // start the player
  PlayFlashSequence((byte*) PB_OpenVisorSeq);         // play flasher sequence
  FlowRepeat = 1;                                     // set the repetitions
  PB_CloseVisorFlag = false;
  ActivateSolenoid(4000, 11);                         // turn the backbox GI off
  ActivateTimer(700, 7, PB_BlinkGI);                  // Blink with GI
  ActivateTimer(2000, 0, PB_OpenVisor);
  ActivateTimer(3000, 1, PB_EyeBlink);
  ActivateSolenoid(0, 13);}

void PB_EyeFlash(byte State) {                        // Blink both lock flashers
  static byte Timer = 0;
  if ((State > 1) || ((State == 1) && !Timer)) {
    ActivateSolenoid(80, 10);
    ActivateSolenoid(80, 18);
    Timer = ActivateTimer(135, 2, PB_EyeFlash);}
  else {
    if (!State) {
      if (Timer) {
        KillTimer(Timer);
        Timer = 0;}
      ReleaseSolenoid (10);
      ReleaseSolenoid (18);}}}

void PB_EyeBlink(byte State) {                        // Blink lock flashers alternately
  static byte Timer = 0;
  if ((State > 1) || ((State == 1) && !Timer)) {
    if (State == 2) {
      ReleaseSolenoid (10);
      if (!QuerySwitch(25)) {
        ActivateSolenoid(0, 18);}
      State = 3;}
    else {
      ReleaseSolenoid (18);
      if (!QuerySwitch(26)) {
        ActivateSolenoid(0, 10);}
      State = 2;}
    Timer = ActivateTimer(250, State, PB_EyeBlink);}
  else {
    if (!State) {
      if (Timer) {
        KillTimer(Timer);
        Timer = 0;}
      ReleaseSolenoid (10);
      ReleaseSolenoid (18);}}}

void PB_ChestLightHandler(byte State) {               // handle chest lights timer (0 -> stop, 1 -> show hit animation, 100 -> start pattern mode)
  static byte Timer = 0;
  static uint16_t PatternCounter = 0;                 // counter for the current chest lamp pattern to be shown
  if (State) {
    if (State < 12 ) {                                // is an animation for a row / column hit requested or running?
      if (State < 6) {                                // turn on phase
        TurnOnLamp(PB_ChestRows[AppByte][State-1]);}
      else {                                          // turn off phase
        TurnOffLamp(PB_ChestRows[AppByte][State-6]);}
      State++;
      if (State < 11) {                               // not yet done
        if (State == 1 && Timer) {                    // timer already running
          KillTimer(Timer);}                          // kill old process
        Timer = ActivateTimer(100, State, PB_ChestLightHandler);} // come back with the current state set
      else {
        PB_ChestPatterns = (byte*)PB_RandomChestPat;  // set pattern
        PatternCounter = 0;
        Timer = ActivateTimer(500, 12, PB_ChestLightHandler);}} // come back in pattern mode
    else {                                            // no hit animation running
      if (State == 100 && Timer) {                    // process already running?

        return;}                                      // ignore call
      if (PB_ChestMode && (PB_ChestMode < 11)) {      // visor is closed and can be opened with one row / column hit
        PB_ChestMode++;                               // proceed to next row / column
        if (PB_ChestMode == 11) {                     // last row reached?
          PB_ChestMode = 1;}                          // start with first column
        for (byte i=0; i<5; i++) {                    // turn off previous blinking row / column
          RemoveBlinkLamp(PB_ChestRows[PB_ChestMode-1][i]);}
        for (byte i=0; i<5; i++) {                    // turn on next blinking row / column
          AddBlinkLamp(PB_ChestRows[PB_ChestMode][i], 75);}
        Timer = ActivateTimer(1000, 12, PB_ChestLightHandler);}
      else {                                          // show ChestPatterns
        byte Mask;
        byte Buffer;
        if (!PB_ChestPatterns[6*PatternCounter]) {
          PatternCounter = 0;}
        for (byte x=0; x<5; x++) {                    // for all columns
          Mask = 1;                                   // mask to access the stored lamps for this player
          Buffer = PB_ChestPatterns[6*PatternCounter+x+1]; // buffer the current column
          for (byte i=0; i<5; i++) {                  // for all rows
            if (PB_ChestLamp[Player-1][x] & Mask) {   // if the lamp is stored
              TurnOnLamp(28+8*x+i);}                  // turn it on
            else {                                    // otherwise
              if (Buffer & 1) {
                TurnOnLamp(28+8*x+i);}
              else {
                TurnOffLamp(28+8*x+i);}}              // it is controlled by the pattern
            Mask = Mask<<1;                           // adjust the mask
            Buffer = Buffer>>1;}}                     // and the buffer
        PatternCounter++;
        Timer = ActivateTimer(PB_ChestPatterns[6*(PatternCounter-1)]*10, 12, PB_ChestLightHandler);}}}
  else {
    if (!State) {
      if (PB_ChestMode && (PB_ChestMode < 11)) {
        for (byte i=0; i<5; i++) {                    // turn off blinking row / column
          RemoveBlinkLamp(PB_ChestRows[PB_ChestMode][i]);}}
      if (Timer) {
        KillTimer(Timer);
        Timer = 0;}}}}

void PB_ClearChest() {                                // turn off chest lamps
  byte x = 0;
  byte y = 0;
  for (x=0; x<5; x++) {
    for (y=0; y<5; y++) {
      TurnOffLamp(28+8*x+y);}}}

void PB_SetChestLamps(byte Switch) {                  // add the lamps for the hit row / column in PB_ChestLamp
  byte Pos = 0;
  byte Buffer;
  byte Buffer2 = PB_LampsToLight;
  if (Switch < 5) {                                   // is it a column?
    Buffer = PB_ChestLamp[Player-1][Switch];          // buffer it
    Pos = 16;                                         // start with a mask value of 10000b
    while (Pos && Buffer2) {                          // until all rows are processed or the required number of lamps has been lit
      if (!(Buffer & Pos)) {                          // if the lamp is not lit
        if (Buffer2 == 1) {                           // only once per target hit
          Points[Player] += 2000;
          PB_AddBonus(1);}
        Buffer2--;                                    // reduce the number of lamps to be lit
        PB_LitChestLamps[Player-1]++;                 // increase the number of lit chest lamps
        if (PB_LitChestLamps[Player-1] != 25) {       // complete chest lit?
          PlaySound(51, "1_85.snd");}
        Buffer = Buffer | Pos;}                       // set the corresponding bit in the buffer
      Pos = Pos>>1;}                                  // next row
    PB_ChestLamp[Player-1][Switch] = Buffer;          // copy the buffer to the chest lamp array for this player
    if (Buffer2 == PB_LampsToLight) {                 // Column already full
      PlaySound(50, "0_6f.snd");}}
  else {                                              // it is a row
    Buffer = 1<<(Switch-5);                           // calculate the mask from the row
    Pos = 0;                                          // start on the left of the chest
    while ((Pos < 5) && Buffer2) {                    // until all columns are processed or the required number of lamps has been lit
      if (!(PB_ChestLamp[Player-1][Pos] & Buffer)) {  // if the lamp is not lit
        if (Buffer2 == 1) {                           // only once per taget hit
          Points[Player] += 2000;
          PB_AddBonus(1);}
        Buffer2--;                                    // reduce the number of lamps to be lit
        PB_LitChestLamps[Player-1]++;                 // increase the number of lit chest lamps
        if (PB_LitChestLamps[Player-1] != 25) {       // complete chest lit?
          PlaySound(51, "1_85.snd");}
        PB_ChestLamp[Player-1][Pos] = PB_ChestLamp[Player-1][Pos] | Buffer;} // set the bit for this lamp in the chest lamp array for this player
      Pos++;}
    if (Buffer2 == PB_LampsToLight) {                 // row already full
      PlaySound(50, "0_6f.snd");}}}

void PB_ResetPlayersChestLamps(byte Player) {         // Reset the chest lamps for this player
  for (byte c=0; c<5; c++) {
    PB_ChestLamp[Player-1][c] = 0;}}

void PB_2ndLock(byte State) {
  switch(State) {
  case 0:                                             // subsequent call from PB_HandleLock
    PB_EyeBlink(1);                                   // restart eye blinking
    RestoreMusicVolume(25);                           // restore music volume after sound has been played
    ReleaseSolenoid(12);                              // turn on playfield GI
    break;
  case 1:                                             // initial call
    MusicVolume = 3;                                  // reduce music volume
    PlayMusic(50, "1_94.snd");                        // play non looping part of music track
    QueueNextMusic("1_94L.snd");                      // queue looping part as next music to be played}
    PlaySound(55, "0_c9.snd");                        // 'partial link-up'
    ActivateTimer(1450, 0, PB_2ndLock);               // call after sound
    break;
  case 2:
    RestoreMusicVolume(25);                           // restore music volume after sound has been played
    ReleaseSolenoid(12);                              // turn on playfield GI
    break;
  }}

void PB_HandleLock(byte State) {
  if (!State) {                                       // routine didn't call itself
    PB_IgnoreLock = false;
    InLock++;}
  byte c = 0;
  if (QuerySwitch(25)) {                              // count locked balls
    c++;}
  if (QuerySwitch(26)) {
    c++;}
  if (c != InLock) {                                  // not as expected?
    InLock = c;                                       // take the new count value
    ActivateTimer(200, 1, PB_HandleLock);}            // and come back to recheck
  else {                                              // number of locked balls as expected
    if (InLock) {                                     // locked ball found?
      if (game_settings[PB_Multiballs]) {             // 3 ball multiball mode?
        switch (PB_MballState) {
        case 1:                                       // one ball locked
          if (InLock == 1) {
            ActivateSolenoid(0, 12);                  // turn off playfield GI
            PB_EyeBlink(0);                           // stop eye blinking
            PlayFlashSequence((byte*) PB_Ball_Locked);
            PlayMusic(50, "1_80.snd");
            ActivateTimer(1000, 1, PB_2ndLock);       // 'partial link up'
            PB_GiveBall(2);
            PB_MballState = 2;}
          else {                                      // not the correct amount of balls in lock
            if (InLock) {                             // two balls in lock
              PB_MballState = 2;
              ActivateTimer(200, 1, PB_HandleLock);}}
          break;
        case 2:                                       // second ball locked
        case 6:                                       // second ball re-locked
          //PB_EyeFlash(1);
          if (InLock == 2) {                          // correct number of balls in lock?
            MusicVolume = 3;
            PB_HandleEjectHole(15);                   // start eject hole animation
            PlaySound(55, "0_b0.snd");                // 'now I see you'
            ActivateTimer(2400, 25, RestoreMusicVolume);  // restore music volume after sound has been played
            ActivateTimer(2000, 0, PB_CloseVisor);    // close visor
            ActivateSolenoid(0, 13);                  // start visor motor
            PB_GiveBall(1);
            PB_MballState = 3;}
          break;
        case 4:                                       // 3 ball multiball
          ActivateTimer(game_settings[PB_MballHoldTime]*1000, 0, PB_ClearOutLock);
          break;
        case 5:                                       // still two balls in game
          PB_MballState = 6;
          PlayMusic(50, "1_03L.snd");                     // play 2nd lock music track
          QueueNextMusic("1_03L.snd");
          if (InLock == 2) {                          // second ball also locked?
            ActivateTimer(200, 1, PB_HandleLock);}
          break;}}
      else {                                          // 2ball multiball mode
        if (PB_ChestMode) {                           // visor is supposed to be closed
          PB_ClearOutLock(1);}                        // remove balls from lock
        else {
          if (InLock == 1) {
            if (Multiballs > 1) {                     // multiball already running?
              MusicVolume = 4;                        // reduce music volume
              PlayMusic(50, "1_05.snd");
              AddBlinkLamp(35, 100);                  // start blinking of solar energy ramp
              PB_OpenVisorFlag = false;
              PB_EyeBlink(0);                         // turn off eye blinking
              PlaySound(55, "0_ae.snd");              // 'shoot for solar value'
              ActivateTimer(2400, 25, RestoreMusicVolume);  // restore music volume after sound has been played
              ActivateTimer(2000, 0, PB_CloseVisor);  // close visor
              ActivateSolenoid(0, 13);                // start visor motor
              PB_SolarValueTimer = ActivateTimer(10000, 0,PB_ReopenVisor);} // 8s to score the solar value
            else {                                    // multiball not yet running
              if (QuerySwitch(17)) {                  // still one ball in the trunk?
                ActivateSolenoid(0, 12);              // turn off playfield GI
                PB_EyeBlink(0);                       // stop eye blinking
                PlayFlashSequence((byte*) PB_Ball_Locked);
                PlayMusic(52, "1_80.snd");
                ActivateTimer(1000, 1, PB_2ndLock);
                PB_GiveBall(1);}}}                    // give second ball
          else {                                      // both balls in lock
            if (Multiballs == 1) {                    // multiball not yet running?
              InLock = 0;
              StopPlayingMusic();
              PB_EyeBlink(0);                         // turn off eye blinking
              ActivateSolenoid(0, 11);                // turn off GI
              ActivateSolenoid(0, 12);
              ActivateSolenoid(0, 9);
              ActivateSolenoid(0, 10);
              ActivateSolenoid(0, 18);
              LampPattern = NoLamps;                  // Turn off all lamps
              PB_LampSweepActive = 2;
              PB_LampSweep(4);
              PB_EyeFlash(1);
              PlaySound(55, "0_b0.snd");              // 'now I see you'
              ActivateTimer(2400, 0, PB_Multiball);   // call after sound
              Multiballs = 2;}                        // start multiball
            else {                                    // second ball is not supposed to be there
              if (!PB_SolarValueTimer) {              // 'shoot for solar value' phase not running?
                ActivateTimer(200, 1, PB_HandleLock);} // come back to recheck after ball eject
              PB_ClearOutLock(1);}}}}}}}              // eject 1 ball and close visor

void PB_HandleEjectHole(byte State) {
  static bool EjectIgnore = false;
  static byte MBallAnimation = 0;
  static byte Timer = 0;
  const byte AniPattern[7] = {0b1000, 0b1001, 0b1011, 0b0111, 0b0110, 0b0100,0};
  switch (State) {
  case 1:                                             // initial call
    if (!EjectIgnore) {                               // hole not locked?
      EjectIgnore = true;                             // lock it
      ActivateTimer(200, 2, PB_HandleEjectHole);}
    break;
  case 2:                                             // ball has settled
    if (QuerySwitch(38)) {                            // is it still in the hole?
      PB_AddBonus(1);
      if (PB_MballState == 4) {                       // 3 ball multiball running?
        ActivateTimer(game_settings[PB_MballHoldTime]*1000, 3, PB_HandleEjectHole);}
      else {
        if (PB_MballState == 3) {                     // 3 ball multiball to start?
          PlaySound(55, "0_ae.snd");                  // 'shoot for solar value'
          Multiballs = 3;                             // set score multiplier
          PB_MballState = 4;
          PlayMusic(50, "1_05.snd");
          AddBlinkLamp(35, 100);                      // start blinking of solar energy ramp
          PB_HandleEnergy(0);                         // turn off energy and lower ramp
          ActivateTimer(1000, 3, PB_HandleEjectHole);
          PB_ClearOutLock(0);
          ActivateTimer(2400, 0, PB_Multiball);}      // call after sound
        else {                                        // no 3 ball multiball to start
          if (PB_EjectMode[Player] < 5) {             // eject hole not lit
            PlaySound(51, "1_a3.snd");
            if (LampPattern == LampColumns) {         // only if no other lamp effect is running
              PatPointer = PB_EjectHole;              // set the pointer to the lamp pattern
              FlowRepeat = 1;                         // set the repetitions
              ActivateTimer(1700, 0, PB_EnergyRestoreLamps) ;  // call this when the lamp pattern has run out
              ShowLampPatterns(1);}                   // play the lamp pattern
            Points[Player] += 10000;
            ShowPoints(Player);
            ActivateTimer(1000, 3, PB_HandleEjectHole);}
          else {                                      // eject hole lit
            ActivateTimer(400, 7, PB_PlayEjectHoleSounds);
            if (PB_EjectMode[Player] == 9) {
              RemoveBlinkLamp(15);
              TurnOnLamp(15);
              PB_EjectMode[Player] = 4;
              Points[Player] += Multiballs * 75000;}
            else {
              RemoveBlinkLamp(PB_EjectMode[Player] + 8);
              TurnOnLamp(PB_EjectMode[Player] + 8);
              PlayFlashSequence((byte*) PB_OpenVisorSeq); // play flasher sequence
              Points[Player] += Multiballs * (PB_EjectMode[Player] - 4) * 25000;
              ShowPoints(Player);
              PB_EjectMode[Player] = PB_EjectMode[Player] - 4;
              if (PB_EjectMode[Player] == 4) {
                PB_AddExBall();}}
            ActivateTimer(1000, 3, PB_HandleEjectHole);}}}}
    else {
      EjectIgnore = false;}
    break;
  case 3:
    ActA_BankSol(3);                                  // eject ball
    ActivateTimer(200, 4, PB_HandleEjectHole);
    break;
  case 4:                                             // check whether ball is gone
    if (QuerySwitch(38)) {
      ActivateTimer(100, 3, PB_HandleEjectHole);}
    else {
      EjectIgnore = false;}
    break;
  case 10:                                            // restore eject hole lamps
    if (PB_EjectMode[Player] < 5) {
      for (byte i=0; i<PB_EjectMode[Player]; i++) {
        TurnOnLamp(13+i);}}
    else {
      for (byte i=0; i<(PB_EjectMode[Player]-5); i++) {
        TurnOnLamp(13+i);}
      AddBlinkLamp(PB_EjectMode[Player]+8, 100);}
    break;
  case 11:                                            // proceed to next eject hole state
    if (!MBallAnimation) {                            // no multiball animation running
      if (PB_EjectMode[Player] < 5) {
        if (PB_EjectMode[Player] == 4) {
          AddBlinkLamp(15, 100);}
        else {
          AddBlinkLamp(PB_EjectMode[Player]+13, 100);}
        PB_EjectMode[Player] = PB_EjectMode[Player] + 5;}}
    break;
  case 15:                                            // switch to 3 ball multiball animation
    if (!MBallAnimation && !Timer) {                  // multiball animation already running?
      if (PB_EjectMode[Player] > 4) {                 // any blinking eject mode lamps?
        if (PB_EjectMode[Player] == 9) {              // turn them off
          RemoveBlinkLamp(15);}
        else {
          RemoveBlinkLamp(PB_EjectMode[Player] + 8);}}
      MBallAnimation = 1;
      Timer = ActivateTimer(10, 20, PB_HandleEjectHole);} // start animation
    break;
  case 16:                                            // end animation
    if (Timer) {
      KillTimer(Timer);
      Timer = 0;}
    MBallAnimation = 0;
    TurnOffLamp(13);
    TurnOffLamp(14);
    TurnOffLamp(15);
    TurnOffLamp(16);
    ActivateTimer(10, 10, PB_HandleEjectHole);        // restore eject hole lamps
    break;
  case 20:                                            // play animation
    byte Buff = AniPattern[MBallAnimation-1];
    for (byte i=0; i<4; i++) {
      if (Buff & 1) {
        TurnOnLamp(13+i);}
      else {
        TurnOffLamp(13+i);}
      Buff = Buff>>1;}
    if (MBallAnimation < 7) {
      MBallAnimation++;
      Timer = ActivateTimer(120, 20, PB_HandleEjectHole);}
    else {
      MBallAnimation = 1;
      Timer = ActivateTimer(900, 20, PB_HandleEjectHole);}
    break;}}

void PB_Multiball_RestoreLamps(byte Dummy) {
  UNUSED(Dummy);
  PB_EyeBlink(1);
  StrobeLights(0);
  LampPattern = LampColumns;}

void PB_MballDisplay(byte Step) {
  const byte PB_2MballDispUpper[78] = {17,0,81,4,85,4,93,4,92,4,76,4,12,0,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,17,0,81,4,85,4,93,4,92,4,76,4,12,0,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};    // display pattern during 2 ball multiball
  const byte PB_2MballDispLower[78] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,96,0,98,0,106,0,122,0,90,0,26,0,24,0,16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
  const byte PB_3MballDispUpper[78] = {3,0,67,4,71,4,79,4,78,4,76,4,12,0,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,3,0,67,4,71,4,79,4,78,4,76,4,12,0,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};    // display pattern during 3 ball multiball
  const byte PB_3MballDispLower[78] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,160,0,162,0,170,0,186,0,154,0,26,0,24,0,16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
  static byte Timer = 0;
  byte *PB_MballDispUpper;
  byte *PB_MballDispLower;
  if (Multiballs == 3) {
    PB_MballDispUpper = (byte* ) PB_3MballDispUpper;
    PB_MballDispLower = (byte* ) PB_3MballDispLower;}
  else {
    PB_MballDispUpper = (byte* ) PB_2MballDispUpper;
    PB_MballDispLower = (byte* ) PB_2MballDispLower;}
  if (!Step) {
    if (Timer) {
      KillTimer(Timer);
      Timer = 0;}}
  else {
    Step--;
    if (Player != 1) {
      for (byte y=0;y<14;y++) {
        *(DisplayUpper+y+2) = PB_MballDispUpper[2*Step+y];}}
    if (Player != 2) {
      for (byte y=0;y<14;y++) {
        *(DisplayUpper+y+18) = PB_MballDispUpper[2*Step+y+18];}}
    if (Player != 3) {
      for (byte y=0;y<14;y++) {
        *(DisplayLower+y+2) = PB_MballDispLower[2*Step+y];}}
    if (Player != 4) {
      for (byte y=0;y<14;y++) {
        *(DisplayLower+y+18) = PB_MballDispLower[2*Step+y+18];}}
    if (!Step) {
      Step = 24;}
    Timer = ActivateTimer(50, Step, PB_MballDisplay);}}

void PB_Multiball(byte State) {                       // state machine for sound effects during multiball start
  switch(State){
  case 0:                                             // initial call from PB_HandleLock
    PlaySound(51, "1_80.snd");
    ActivateTimer(1200, 1, PB_Multiball);
    PB_EyeFlash(0);
    PB_ShowMessage(254);                              // block display messages
    PB_MballDisplay(24);                              // show display animation
    PatPointer = PB_MultiballPat;                     // set the pointer to the lamp pattern
    FlowRepeat = 1;                                   // set the repetitions
    ActivateTimer(6100, 0, PB_Multiball_RestoreLamps) ; // call this when the lamp pattern has run out
    ShowLampPatterns(1);                              // play the lamp pattern
    StrobeLights(3);                                  // and strobe the lights while doing so
    ReleaseSolenoid(9);
    ReleaseSolenoid(10);
    ReleaseSolenoid(18);
    ReleaseSolenoid(12);
    PlayFlashSequence((byte*) PB_MultiballSeq);
    break;
  case 1:
    if (!game_settings[PB_Multiballs]) {              // not in 3 ball multiball mode?
      PlayMusic(50, "1_04.snd");}
    QueueNextMusic("1_04L.snd");                      // queue looping part as next music to be played
    PlaySound(52, "1_80.snd");
    ActivateTimer(1000, 2, PB_Multiball);
    break;
  case 2:
    PlaySound(52, "1_80.snd");
    ActivateTimer(2400, 3, PB_Multiball);
    break;
  case 3:
    PlaySound(52, "1_80.snd");
    break;
  case 10:                                            // back to main theme
    PlayMusic(50, "1_01L.snd");
    QueueNextMusic("1_01L.snd");                      // queue looping part as next music to be played
    break;}}

void PB_LampSweep(byte Step) {
  TurnOffLamp(Step);
  if (PB_LampSweepActive) {
    if (PB_LampSweepActive > 1) {
      Step++;
      if (Step > 8) {
        Step = 8;
        PB_LampSweepActive = 1;}}
    else {
      Step--;
      if (Step < 4) {
        Step = 4;
        PB_LampSweepActive = 2;}}
    TurnOnLamp(Step);
    ActivateTimer(100, Step, PB_LampSweep);}}

void PB_ReopenVisor(byte Dummy) {                     // reopen visor if solar value ramp was not hit in time
  UNUSED(Dummy);
  if (Multiballs == 2) {
    PB_EyeBlink(1);}
  PB_SolarValueTimer = 0;
  RemoveBlinkLamp(35);                                // solar energy lamp
  PB_ClearOutLock(0);}

void PB_ClearOutLock(byte State) {                    // CloseVisor = 0 -> eject 1 ball / CloseVisor = 1 -> Visor will be closed / = 2 -> clear out both balls but don't close visor
  static byte Timer = 0;
  if (State < 3) {                                    // inital call?
    if (Timer) {
      KillTimer(Timer);}
    State += 3;}
  Timer = 0;
  if (QuerySolenoid(13)) {                            // visor motor on?
    Timer = ActivateTimer(1100, State, PB_ClearOutLock);}     // come back later
  else {
    if (QuerySwitch(47)) {                            // visor is open
      if (QuerySwitch(25)) {                          // left eye?
        ActA_BankSol(7);                              // eject it
        if (QuerySwitch(26) && State == 5) {          // 2nd ball shall be ejected also
          Timer = ActivateTimer(1000, 3, PB_ClearOutLock);}
        else if (State == 4) {                        // closed visor requested?
          ActivateTimer(1000, 1, PB_CloseVisor);}}
      else {
        if (QuerySwitch(26)) {                        // right eye
          ActA_BankSol(8);}                           // eject it
        if (State == 4) {                             // closed visor requested?
          ActivateTimer(1000, 1, PB_CloseVisor);}}}   // set close flag
    else if (QuerySwitch(25) || QuerySwitch(26)) {    // open visor if there's still a ball in lock
      ActivateTimer(1000, 0, PB_OpenVisor);
      PlaySound(52, "0_f1.snd");                      // moving visor sound
      ActivateSolenoid(0, 13);                        // activate visor motor
      Timer = ActivateTimer(2000, State, PB_ClearOutLock);}}}

void PB_DropTargetReset(byte Counter) {
  PlaySound(52, "0_9b.snd");
  Counter--;
  if (Counter) {
    ActivateTimer(110, Counter, PB_DropTargetReset);}
  else {
    PB_CycleDropLights(1);                            // start the blinking drop target lights
    ActA_BankSol(4);}}                                // reset drop targets

void PB_EnergyReset(byte Counter) {
  PlaySound(52, "0_9b.snd");
  Counter--;
  if (Counter) {
    ActivateTimer(110, Counter, PB_EnergyReset);}
  else {
    PB_EnergyActive = false;                          // energy value off
    PB_DropRamp = true;}}                             // ramp needs to be dropped

void PB_TurnOffLamp(byte Lamp) {
  TurnOffLamp(Lamp);}

void PB_HandleEnergy(byte State) {
  static byte Timer = 0;
  static uint16_t Time;
  if ((State > 1) || ((State == 1) && !Timer)) {
    if (State == 1) {
      Time = 0;}
    uint16_t Length = 550 - (430 * Time / (1000 * game_settings[PB_EnergyTime])); // time to the next blink
    Time = Time + Length;                             // total time
    if (Time < 1000 * game_settings[PB_EnergyTime]) { // total time < selected energy time?
      TurnOnLamp(34);
      PlaySound(50, "0_a2.snd");
      ActivateTimer(Length/2, 34, PB_TurnOffLamp);
      Timer = ActivateTimer(Length, 2, PB_HandleEnergy);}
    else {                                            // energy time has run out
      //RestoreMusicVolume(10);
      TurnOffLamp(34);
      Timer = 0;
      PB_EnergyReset(5);}}
  else {
    if (!State) {
      TurnOffLamp(34);
      //RestoreMusicVolume(10);
      if (Timer) {
        KillTimer(Timer);}
      Timer = 0;
      PB_EnergyActive = false;                        // energy value off
      PB_DropRamp = true;}}}                          // ramp needs to be dropped

void PB_HandleDropTargets(byte Target) {
  static byte PB_DropTimer;
  static uint16_t Time;
  static bool SoundState;
  if (Target && Target != 100) {                      // target hit? Target = 100 is the stop command
    Points[Player] += 1000;
    PB_DropWait = false;                              // stop ignoring drop target switches
    if (QuerySwitch(49) && QuerySwitch(50) && QuerySwitch(51)) {  // all targets down
      Points[Player] += 25000;
      if (PB_DropTimer) {                             // any targets down before?
        KillTimer(PB_DropTimer);                      // turn off timer
        PB_DropTimer = 0;
        PB_DropBlinkLamp = 41;
        PB_CycleDropLights(1);                        // start the blinking drop target lights
        TurnOffLamp(17);}                             // turn off timer lamp
      Points[Player] += Multiballs * 25000;
      ActA_BankSol(4);                                // reset drop targets
      PB_AdvancePlanet(1);}
    else {
      if (!PB_DropTimer) {                            // first target hit
        if (Target-8 == PB_DropBlinkLamp && PB_MballState != 4) { // blinking target hit?
          //MusicVolume = 4;                            // reduce music volume
          PlaySound(51, "0_71.snd");
          ActivateTimer(1000, 0, PB_RaiseRamp);       // raise ramp in 1s
          PB_EnergyActive = true;                     // energy value on
          ActivateTimer(500, 1, PB_HandleEnergy);}
        Time = 0;                                     // reset drop target time
        SoundState = true;
        PB_CycleDropLights(0);                        // stop blinking of drop target lights
        PB_DropTimer = ActivateTimer(550, 0, PB_HandleDropTargets);}}}
  else {
    uint16_t Length = 550 - (430 * Time / (1000 * game_settings[PB_DropTime])); // time to the next blink
    Time = Time + Length;                             // total time
    if (Time < 1000 * game_settings[PB_DropTime] && !Target) {   // total time < selected drop target time? Stop command?
      TurnOnLamp(17);
      if (!PB_EnergyActive) {
        if (SoundState) {
          SoundState = false;
          PlaySound(50, "0_a6.snd");}
        else {
          SoundState = true;
          PlaySound(50, "0_a1.snd");}}
      ActivateTimer(Length/2, 17, PB_TurnOffLamp);
      PB_DropTimer = ActivateTimer(Length, 0, PB_HandleDropTargets);}
    else {                                            // drop target time has run out
      if (Target && PB_DropTimer) {                   // stop command received?
        KillTimer(PB_DropTimer);}
      TurnOffLamp(17);
      PB_DropBlinkLamp = 41;
      PB_DropTimer = 0;
      PB_DropTargetReset(5);}}}                       // initiate reset

void PB_RaiseRamp(byte Dummy) {
  UNUSED (Dummy);
  if (QuerySwitch(44)) {                              // ramp still down?
    ActA_BankSol(5);                                  // raise ramp
    ActivateTimer(1000, 0, PB_RaiseRamp);}}           // recheck in 1s

void PB_AdvancePlanet2(byte State) {                  // finale of the 'sun reached' animation
  if (State < 10) {
    SwitchDisplay(0);
    if (State % 2) {
      PlaySound(53, "0_91.snd");
      WriteUpper2("SPECIAL LIT   ");}
    else {
      WriteUpper2("              ");}
    ActivateTimer(180, State+1, PB_AdvancePlanet2);}
  else {
    for (byte i=0; i<9; i++) {                        // turn off planet lamps
      TurnOffLamp(19 + i);}
    RestoreMusicVolume(25);
    //PB_Planet[Player] = 0;
    SwitchDisplay(1);}}                               // switch display back to normal

void PB_AdvancePlanet(byte State) {
  byte Planets = PB_Planet[Player];
  switch (State) {
  case 0:                                             // to be called by AfterSound
    RemoveBlinkLamp(19+game_settings[PB_ReachPlanet]);
    RemoveBlinkLamp(51);                              // stop blinking of special lamp
    if (PB_Planet[Player] && PB_Planet[Player] != 10 && PB_Planet[Player] != 20) { // planets lit?
      TurnOnLamp(19+game_settings[PB_ReachPlanet]);}
    PB_GiveExBall();
    RestoreMusicVolume(25);
    break;
  case 1:                                             // initial call
    PB_Planet[Player]++;                              // player has reached next planet
    if (PB_Planet[Player] > 20) {                     // sun already reached for the 2nd time?
      PB_Planet[Player] = 11;}                        // set it back to the sun
    Planets = PB_Planet[Player];
    if (PB_Planet[Player] == game_settings[PB_ReachPlanet]+1) { //  blinking planet reached?
      MusicVolume = 4;                                // reduce music volume
      PlayFlashSequence((byte*) PB_OpenVisorSeq);     // play flasher sequence
      ActC_BankSol(1);                                // use knocker
      PlaySound(53, "1_ab.snd");
      ActivateTimer(4300, 0, PB_AdvancePlanet);}      // jump to case 0 after sound has been played
    else if  (PB_Planet[Player] == 10 || PB_Planet[Player] == 20) { // is it the sun?
      MusicVolume = 4;                                // reduce music volume
      PlaySound(53, "0_e1.snd");
      ActC_BankSol(8);                                // sun flasher
      for (byte i=0; i<9; i++) {                      // turn off planet lamps
        TurnOffLamp(19 + i);}
      ActivateTimer(150, 30, PB_AdvancePlanet);
      PB_SpecialLit = true;
      AddBlinkLamp(51, 100);}
    else {
      ActC_BankSol(8);                                // sun flasher
      char FileName[13] = "0_e1_000.snd";
      if (Planets > 10) {                             // sun already reached?
        Planets = Planets - 10;}
      FileName[7] = 48 + (Planets % 10);
      FileName[6] = 48 + (Planets / 10);
      PlaySound(51, (char*) FileName);
      QueueNextSound("0_e1_000.snd");
      ActivateTimer(500, 2, PB_AdvancePlanet);
      ActivateTimer(4050, 21, PB_AdvancePlanet);      // reset AfterSound
      RemoveBlinkLamp(19+game_settings[PB_ReachPlanet]);} // stop blinking
    break;
  case 2:                                             // first step of advance planet
    if (Planets > 10) {                               // sun already reached?
      Planets = Planets - 10;}
    if (Planets < 9) {
      TurnOnLamp(27);
      ActivateTimer(350, State+1, PB_AdvancePlanet);}
    else {
      AddBlinkLamp(27, 100);
      State = 20;
      ActivateTimer(1000, 20, PB_AdvancePlanet);}
    break;
  case 20:                                            // animation reached planet
    if (PB_Planet[Player] < game_settings[PB_ReachPlanet]+1) {
      AddBlinkLamp(19+game_settings[PB_ReachPlanet], 100);}
    if (Planets > 10) {                               // sun already reached?
      Planets = Planets - 10;}
    RemoveBlinkLamp(18 + Planets);
    TurnOnLamp(18 + Planets);
    break;
  case 21:                                            // reset AfterSound
    AfterSound = 0;
    break;
  case 30:                                            // first step off sun reached animation
    TurnOnLamp(19);
    ActivateTimer(150, 31, PB_AdvancePlanet);
    break;
  case 54:                                            // final step of sun reached animation
    for (byte i=0; i<9; i++) {                        // turn off planet lamps
      TurnOffLamp(19 + i);}
    PlaySound(55, "0_b3.snd");                        // 'We control the universe'
    ActivateTimer(2700, 0, PB_AdvancePlanet2);
    break;
  default:                                            // all intermediate steps
    if (State < 30) {                                 // advance planet animation?
      TurnOffLamp(30 - State);
      if (Planets > 10) {                             // sun already reached?
        Planets = Planets - 10;}
      if (State < 11 - Planets) {                     // not the final step?
        TurnOnLamp(29 - State);
        ActivateTimer(350, State+1, PB_AdvancePlanet);}
      else {                                          // final step
        AddBlinkLamp(18 + Planets, 100);
        ActivateTimer(1000, 20, PB_AdvancePlanet);}}
    else {                                            // sun reached animation
      if (State < 38) {                               // planets being lit
        TurnOnLamp(State - 11);
        ActivateTimer(120, State+1, PB_AdvancePlanet);}
      else {                                          // all planets lit
        ActC_BankSol(3);
        ActC_BankSol(4);
        ActC_BankSol(8);                              // sun flasher
        PlaySound(53, "0_99.snd");
        if (State % 2) {                              // toggle planet lamps
          TurnOffLamp(19);
          TurnOffLamp(21);
          TurnOffLamp(23);
          TurnOffLamp(25);
          TurnOffLamp(27);
          TurnOnLamp(20);
          TurnOnLamp(22);
          TurnOnLamp(24);
          TurnOnLamp(26);}
        else {
          TurnOnLamp(19);
          TurnOnLamp(21);
          TurnOnLamp(23);
          TurnOnLamp(25);
          TurnOnLamp(27);
          TurnOffLamp(20);
          TurnOffLamp(22);
          TurnOffLamp(24);
          TurnOffLamp(26);}
        ActivateTimer(180, State+1, PB_AdvancePlanet);}}}}

void PB_CycleDropLights(byte State) {                 // State = 0 -> Stop / State = 1 -> Start / State = 2 -> called by timer
  static byte Timer;
  if ((State == 2) || ((State == 1) && !Timer)) {     // State = 1 is a new start and not allowed when timer is already running
    if (PB_DropBlinkLamp) {                           // blink lamp active?
      if (PB_DropBlinkLamp == 43) {                   // last lamp blinking?
        AddBlinkLamp(41, 100);                        // start again with the first one
        RemoveBlinkLamp(43);                          // remove the current one
        PB_DropBlinkLamp = 41;}                       // reset the number of the currently blinking lamp
      else {                                          // not the last one
        AddBlinkLamp(PB_DropBlinkLamp+1, 100);        // start the next one
        RemoveBlinkLamp(PB_DropBlinkLamp);            // remove the current one
        PB_DropBlinkLamp++;}                          // increase number of currently blinking lamp
      Timer = ActivateTimer(3000, 2, PB_CycleDropLights);}}
  else {
    if (!State) {                                     // stop command
      if (Timer) {
        KillTimer(Timer);
        Timer = 0;}
      if (PB_DropBlinkLamp) {                         // blink lamp active?
        RemoveBlinkLamp(PB_DropBlinkLamp);
        PB_DropBlinkLamp = 0;}}}}

void PB_PlayMultiplierSequence(byte State) {
  static byte Timer = 0;
  if ((State > 1) || ((State == 1) && !Timer)) {
    PlayFlashSequence((byte*) PB_MultiplierSeq);
    Timer = ActivateTimer(2100, 2, PB_PlayMultiplierSequence);}
  else if (!State) {
    if (Timer) {
      KillTimer(Timer);
      Timer = 0;}}}

void PB_PlayAfterGameSequence(byte State) {
  static byte Timer = 0;
  if ((State > 1) || ((State == 1) && !Timer)) {
    if (State == 1) {
      PlaySound(53, "0_b1.snd");
      ActivateSolenoid(0, 9);
      ActivateSolenoid(0, 11);
      ActivateSolenoid(0, 12);
      Timer = ActivateTimer(1205, 2, PB_PlayAfterGameSequence);}
    else if (State == 2) {
      PlayMusic(50, "1_86.snd");
      ReleaseSolenoid(9);
      Timer = ActivateTimer(10, 4, PB_PlayAfterGameSequence);}
    else if (State < 64) {
      if (!(State & 3)) {
        ReleaseSolenoid(11);}
      else if ((State & 3) == 1) {
        ActivateSolenoid(0, 11);}
      else if ((State & 3) == 2) {
        ReleaseSolenoid(12);}
      else if ((State & 3) == 3) {
        ActivateSolenoid(0, 12);}
      Timer = ActivateTimer(35, State+1, PB_PlayAfterGameSequence);}
    else if (State == 64) {
      ActivateSolenoid(0, 9);
      MusicVolume = 3;
      Timer = ActivateTimer(50, State+1, PB_PlayAfterGameSequence);}
    else if (State == 65) {
      ReleaseSolenoid(9);
      PlaySound(53, "0_d7.snd");
      PlayFlashSequence((byte*) PB_LeftBBinserts);
      Timer = ActivateTimer(500, State+1, PB_PlayAfterGameSequence);}
    else if (State == 66) {
      ActivateSolenoid(0, 9);
      MusicVolume = 3;
      Timer = ActivateTimer(500, State+1, PB_PlayAfterGameSequence);}
    else if (State == 67) {
      ReleaseSolenoid(9);
      PlayFlashSequence((byte*) PB_RightBBinserts);
      PlayMusic(50, "1_03L.snd");
      QueueNextMusic("1_03L.snd");
      PlaySound(53, "0_d7.snd");
      Timer = ActivateTimer(500, State+1, PB_PlayAfterGameSequence);}
    else if (State == 68) {
      ActivateSolenoid(0, 9);
      Timer = ActivateTimer(500, State+1, PB_PlayAfterGameSequence);}
    else if (State == 69) {
      ReleaseSolenoid(9);
      PlayFlashSequence((byte*) PB_BB_FlasherCycle);
      RestoreMusicVolume(25);
      Timer = ActivateTimer(1500, State+1, PB_PlayAfterGameSequence);}
    else if (State < 77) {
      ReleaseSolenoid(9);
      PlayFlashSequence((byte*) PB_BB_FlasherCycle);
      Timer = ActivateTimer(1500, State+1, PB_PlayAfterGameSequence);}
    else if (State == 78) {
      ReleaseSolenoid(9);
      Timer = ActivateTimer(20, State+1, PB_PlayAfterGameSequence);}
    else if (State < 118) {
      if (State & 1) {
        ReleaseSolenoid(11);
        ActivateSolenoid(0, 12);}
      else {
        ReleaseSolenoid(12);
        ActivateSolenoid(0, 11);}
      Timer = ActivateTimer(10*(118-State), State+1, PB_PlayAfterGameSequence);}
    else if (State == 118) {
      ReleaseSolenoid(12);
      AfterMusic = 0;
      PlayMusic(50, "1_80.snd");
      Timer = ActivateTimer(6000, State+1, PB_PlayAfterGameSequence);}
    else {
      Timer = 0;}}
  else {
    if (!State) {
      if (Timer) {
        KillTimer(Timer);
        Timer = 0;}
      StopPlayingMusic();
      ReleaseAllSolenoids();}}}

void PB_BallEnd(byte Balls) {                         // ball has been kicked into trunk
  if (game_settings[PB_Multiballs]) {                 // 3 ball multiball selected?
    switch (PB_MballState) {
    case 4:                                           // 3 ball multiball running
      RemoveBlinkLamp(35);                            // solar energy lamp
      Multiballs = 1;                                 // reset score multiplier
      PB_MballDisplay(0);                             // stop display animation
      PB_SolarValue = 0;                              // reset jackpot
      PB_MballState = 5;                              // indicate a ball loss
      PB_MballDisplay(0);                             // stop display animation
      PB_ShooterLaneWarning(0);                       // turn off shooter lane warning
      PB_ShowMessage(255);                            // release message block
      ShowAllPoints(0);
      PlayMusic(50, "1_0a.snd");                      // play multiball end theme
      QueueNextMusic("1_02L.snd");                    // track is looping so queue it also
      PB_LampSweepActive = 0;                         // turn off backbox lamp sweep
      PB_HandleEjectHole(16);                         // stop eject hole animation
      ReleaseSolenoid(11);                            // turn backbox GI back on
      if (QuerySwitch(38)) {                          // ball in eject hole?
        ActivateTimer(1000, 3, PB_HandleEjectHole);}  // clear eject hole
      BlockOuthole = false;                           // remove outhole block
      PB_ClearOutLock(2);                             // clear out locks but don't close visor
      InLock = 0;
      return;
    case 5:                                           // 2 balls in game after multiball
    case 6:                                           // 1 ball in lock after multiball
      PB_ClearOutLock(1);                             // clear out lock and close visor
      InLock = 0;
      PB_ChestLightHandler(0);                        // stop chest animation
      PB_ChestMode = 1;
      PB_ClearChest();                                // turn off chest lamps
      PB_ChestLightHandler(100);                      // restart chest animation
      ActivateTimer(3000, 10, PB_Multiball);
      PB_MballState = 1;
      BlockOuthole = false;                           // remove outhole block
      return;}}
  else {                                              // not in 3 ball multiball mode
    PB_EyeBlink(0);
    if (Multiballs == 2) {                            // multiball running?
      if (PB_SolarValueTimer) {                       // solar value jackpot active?
        KillTimer(PB_SolarValueTimer);
        PB_SolarValueTimer = 0;
        RemoveBlinkLamp(35);}                         // solar energy lamp
      Multiballs = 1;                                 // turn it off
      PB_MballDisplay(0);                             // stop display animation
      PB_ShowMessage(255);                            // release message block
      ShowAllPoints(0);
      PB_LampSweepActive = 0;                         // turn off backbox lamp sweep
      ReleaseSolenoid(11);                            // turn backbox GI back on
      if (APC_settings[Volume]) {
        analogWrite(VolumePin,255-APC_settings[Volume]);} // reduce volume back to normal
      PlayMusic(50, "1_0a.snd");                      // play multiball end theme
      QueueNextMusic("1_02L.snd");                    // track is looping so queue it also
      if (Balls == 2) {                               // all balls detected in the trunk
        Balls = PB_CountBallsInTrunk();               // count again
        ActivateTimer(1000, Balls, PB_BallEnd);}      // come back and check again
      else {
        PB_ClearOutLock(1);                           // clear out lock and close visor
        InLock = 0;
        PB_ChestLightHandler(0);                      // stop chest animation
        PB_ChestMode = 1;
        PB_ClearChest();                              // turn off chest lamps
        PB_ChestLightHandler(100);                    // restart chest animation
        ActivateTimer(3000, 10, PB_Multiball);        // return to main music theme
        BlockOuthole = false;}                        // remove outhole block
      return;}}
  PB_HandleDropTargets(100);                          // turn off drop target blinking
  PB_HandleEnergy(0);                                 // turn off energy lamp and sounds
  if (!QuerySwitch(44)) {                             // ramp in up state?
    ActA_BankSol(6);}                                 // drop ramp
  BlinkScore(0);                                      // stop score blinking
  PB_CycleDropLights(0);                              // stop the blinking drop target lights
  PB_ChestLightHandler(0);                            // stop chest animation
  for (byte i=0; i<5; i++) {                          // turn off blinking row / column
    RemoveBlinkLamp(PB_ChestRows[PB_ChestMode][i]);}
  PB_ClearChest();                                    // turn off chest lamps
  if (!PB_ChestMode) {
    if (PB_Chest_Status[Player] < 100) {
      PB_Chest_Status[Player] = PB_Chest_Status[Player] + 100;}} // indicate that the visor has been open
  else {                                              // visor is closed
    if (PB_ChestMode < 11 && PB_LitChestLamps[Player-1]) {  // player already has lit chest lamps
      PB_LitChestLamps[Player-1] += 100;}}            // indicate that the chest lamps have been lit, but the visor is still closed
  RemoveBlinkLamp(19+game_settings[PB_ReachPlanet]);
  if (BallWatchdogTimer) {
    KillTimer(BallWatchdogTimer);
    BallWatchdogTimer = 0;}
  if (PB_EjectMode[Player] > 4) {                     // any blinking eject mode lamps?
    if (PB_EjectMode[Player] == 9) {                  // turn them off
      RemoveBlinkLamp(15);}
    else {
      RemoveBlinkLamp(PB_EjectMode[Player] + 8);}}
  for (byte i=0; i<4; i++) {                      // turn off all eject mode lamps
    TurnOffLamp(13+i);}
  if (PB_BallSave == 2) {                         // ball saver has been triggered
    BlockOuthole = false;                         // remove outhole block
    ActivateTimer(2000, 0, PB_AfterExBallRelease);
    ActivateTimer(1000, Balls, PB_NewBall);}
  else {                                          // no ball saver
    WriteUpper("              ");
    WriteLower("              ");
    WriteUpper2(" BONUS        ");
    ShowNumber(15, Bonus*1000);
    StopPlayingMusic();
    PlaySound(53, "0_2c.snd");
    AppByte = Balls;
    StopAllBlinkLamps();
    ActivateTimer(200, 0, PB_CountBonus);}}

void PB_BlinkPlanet(byte State) {                     // blink planets during bonus count
  static byte Counter = 0;
  switch (Counter) {
  case 0:
  case 2:
  case 4:
    TurnOffLamp(State);
    ActivateTimer(40, State, PB_BlinkPlanet);
    Counter++;
    break;
  case 1:
  case 3:
    TurnOnLamp(State);
    ActivateTimer(80, State, PB_BlinkPlanet);
    Counter++;
    break;
  case 5:
    TurnOnLamp(State);
    Counter = 0;}}

void PB_CountBonus(byte State) {
  static uint32_t TotalBonus;
  const byte Pattern[11] = {5,3,13,14,4,2,12,15,6,10,11};
  if (State < 11) {                                   // show bonus
    *(DisplayUpper+2*Pattern[State]) = *(DisplayUpper2+2*Pattern[State]);
    *(DisplayUpper+2*Pattern[State]+1) = *(DisplayUpper2+2*Pattern[State]+1);
    ActivateTimer(100, State+1, PB_CountBonus);}
  else if (State == 11) {
    StopPlayingSound();
    ActivateTimer(1000, 12, PB_CountBonus);}
  else if (State == 12) {
    WritePlayerDisplay((char*) "  1X   ", 1);
    PlaySound(53, "0_3e.snd");
    TotalBonus = Bonus*1000;
    DisplayScore(2, TotalBonus);
    if (BonusMultiplier > 1) {
      ActivateTimer(300, 13, PB_CountBonus);}
    else {
      ActivateTimer(1000, 20, PB_CountBonus);}}
  else if (State == 13) {
    WritePlayerDisplay((char*) "  2X   ", 1);
    PlaySound(53, "0_3e.snd");
    TotalBonus = Bonus*2000;
    DisplayScore(2, TotalBonus);
    if (BonusMultiplier > 2) {
      ActivateTimer(300, 14, PB_CountBonus);}
    else {
      ActivateTimer(1000, 20, PB_CountBonus);}}
  else if (State == 14) {
    WritePlayerDisplay((char*) "  3X   ", 1);
    PlaySound(53, "0_3e.snd");
    TotalBonus = Bonus*3000;
    DisplayScore(2, TotalBonus);
    if (BonusMultiplier > 3) {
      ActivateTimer(300, 15, PB_CountBonus);}
    else {
      ActivateTimer(1000, 20, PB_CountBonus);}}
  else if (State == 15) {
    WritePlayerDisplay((char*) "  4X   ", 1);
    PlaySound(53, "0_3e.snd");
    TotalBonus = Bonus*4000;
    DisplayScore(2, TotalBonus);
    if (BonusMultiplier > 4) {
      ActivateTimer(300, 16, PB_CountBonus);}
    else {
      ActivateTimer(1000, 20, PB_CountBonus);}}
  else if (State == 16) {
    WritePlayerDisplay((char*) "  5X   ", 1);
    PlaySound(53, "0_49.snd");
    PB_PlayMultiplierSequence(1);
    TotalBonus = Bonus*5000;
    DisplayScore(2, TotalBonus);
    ActivateTimer(1000, 20, PB_CountBonus);}
  else if (State == 20) {                             // start counting bonus
    PlaySound(53, "0_5d.snd");
    DisplayScore(1, Points[Player]);
    ActivateTimer(100, 21, PB_CountBonus);}
  else if (State == 21) {                             // still counting
    TotalBonus = TotalBonus - 1000;
    Points[Player] = Points[Player] + 1000;
    WriteUpper("              ");
    DisplayScore(1, Points[Player]);
    DisplayScore(2, TotalBonus);
    if (TotalBonus) {                                 // still bonus left?
      ActivateTimer(29, 21, PB_CountBonus);}          // continue counting
    else {                                            // check planets
      PB_PlayMultiplierSequence(0);
      if (PB_Planet[Player] && PB_Planet[Player] != 10 && PB_Planet[Player] != 20) { // planets lit?
        ActivateTimer(10, 30, PB_CountBonus);}
      else {                                          // no planets lit
        PlaySound(53, "0_65.snd");
        ActivateTimer(1000, 40, PB_CountBonus);}}}
  else if (State < 40) {                              // count planets
    PlaySound(53, "0_65.snd");
    PB_BlinkPlanet(State-11);
    Points[Player] += 20000;                          // add points for each planet
    WriteUpper((char*)PB_PlanetTxt[State - 30]);         // show planet names
    ShowPoints(Player);
    byte Planets = PB_Planet[Player];
    if (Planets > 10) {                               // sun already reached?
      Planets = Planets - 10;}
    if (Planets == 10) {                              // sun reached for the 2nd time?
      Planets = 0;}
    if (Planets > State - 29) {
      ActivateTimer(500, State+1, PB_CountBonus);}
    else {
      ActivateTimer(1000, 40, PB_CountBonus);}}
  else {
    PB_BallEnd2();}}

void PB_BallEnd2() {
  BlockOuthole = false;                               // remove outhole block
  PlaySound(53, "1_85.snd");
  if (ExBalls) {                                      // Player has extra balls
    AddBlinkLamp(33, 250);                            // Let the extra ball lamp blink
    ExBalls--;
    ActivateTimer(1100, 0, PB_AfterExBallRelease);
    ActivateTimer(100, AppByte+10, PB_NewBall);}
  else {                                              // Player has no extra balls
    TurnOffLamp(51);
    if ((Points[Player] > HallOfFame.Scores[3]) && (Ball == APC_settings[NofBalls])) { // last ball & high score?
      Switch_Pressed = DummyProcess;                  // Switches do nothing
      PB_Congrats(1);}
    else {
      if ((PB_EjectMode[Player] == 4) || (PB_EjectMode[Player] == 9)) { // eject hole mode maxed out?
        PB_EjectMode[Player] = 0;}                    // reset it for the next ball
      PB_BallEnd3(AppByte);}}}

void PB_BallEnd3(byte Balls) {
  LampPattern = LampColumns;
  if (Player < NoPlayers) {                           // last player?
    Player++;
    ActivateTimer(100, Balls, PB_NewBall);}
  else {
    if (Ball < APC_settings[NofBalls]) {              // last ball?
      Player = 1;                                     // not yet
      Ball++;
      ActivateTimer(100, Balls, PB_NewBall);}
    else {                                            // game end
      PB_EyeBlink(0);
      ReleaseSolenoid(23);                            // disable flipper fingers
      ReleaseSolenoid(24);
      LampPattern = NoLamps;                          // Turn off all lamps
      TurnOffLamp(3);                                 // turn off Ball in Play lamp
      PB_HandleEjectHole(16);                         // stop eject hole animation
      PB_PlayAfterGameSequence(1);                    // start end of game animation
      GameDefinition.AttractMode();}}}

void PB_Congrats(byte State) {                        // show congratulations
  static byte Timer = 0;
  switch(State) {
  case 0:
    if (Timer) {
      KillTimer(Timer);
      Timer = 0;}
    break;
  case 1:
    for (byte i=0; i< 8; i++) {
      LampColumns[i] = 0;}
    LampPattern = LampColumns;
    ActC_BankSol(1);
    //AfterMusic = PB_EnterInitials2;                 // TODO fix congrats
    PlayMusic(50, "1_06.snd");
    QueueNextMusic("1_06L.snd");                      // queue looping part as next music to be played}
    ActivateSolenoid(0, 11);
    ActivateSolenoid(0, 12);
    PB_LampSweepActive = 2;
    PB_LampSweep(4);
    WriteUpper("              ");
    WriteLower("              ");
    DisplayScore(3, Points[Player]);
    DisplayScore(4, Points[Player]);
    WriteUpper2(" GREAT        ");
    ActivateTimer(50, 0, ScrollUpper);
    ActivateTimer(1400, 1, PB_ScrollCongrats);
    //ActivateTimer(3000, 1, PB_ScrollCongrats2);
    ActivateTimer(5000, Player, PB_Congrats2);
    Timer = ActivateTimer(3000, 2, PB_Congrats);
    break;
  case 2:
    PlayFlashSequence((byte*) PB_BB_FlasherCycle);
    Timer = ActivateTimer(3000, 2, PB_Congrats);
    break;}}

void PB_ScrollCongrats(byte Dummy) {
  UNUSED(Dummy);
  WriteUpper2("  SCORE       ");
  AddScrollUpper(0);}

void PB_Congrats2(byte Dummy) {
  UNUSED(Dummy);
  WriteUpper2("ENTER         ");
  ActivateTimer(50, 0, ScrollUpper);
  ActivateTimer(1400, 1, PB_ScrollCongrats2);}

void PB_ScrollCongrats2(byte Dummy) {
  UNUSED(Dummy);
  WriteUpper2(" INITIALS     ");
  AddScrollUpper(0);
  ActivateTimer(3000, 1, PB_ScrollCongrats3);}

void PB_ScrollCongrats3(byte Dummy) {
  UNUSED(Dummy);
  WriteUpper2("PLAYER        ");
  *(DisplayUpper2+14) = DispPattern1[32 + 2 * Player];
  *(DisplayUpper2+15) = DispPattern1[33 + 2 * Player];
  ScrollUpper(0);
  ActivateTimer(2000, 0, PB_EnterInitials);
  ByteBuffer = 0;}

void PB_EnterInitials(byte Switch) {
  switch (Switch) {
  case 0:
    Switch_Pressed = PB_EnterInitials;
    EnterIni[0] = 'A';
    EnterIni[1] = 'A';
    EnterIni[2] = 'A';
    PB_BlinkInitial(0);
    break;
  case 3:                                             // credit button
    KillTimer(ByteBuffer2);
    ByteBuffer++;
    if (ByteBuffer > 2) {
      FadeOutMusic(100);
      ActivateTimer(1000, 0, PB_EnterInitials2);}
    else {
      PB_BlinkInitial(1);}
    break;
  case 10:                                            // left flipper button
    if (EnterIni[ByteBuffer] == 65) {
      EnterIni[ByteBuffer] = 57;}
    else if (EnterIni[ByteBuffer] == 48) {
      EnterIni[ByteBuffer] = 32;}
    else if (EnterIni[ByteBuffer] == 32) {
      EnterIni[ByteBuffer] = 90;}
    else {
      EnterIni[ByteBuffer]--;}
    KillTimer(ByteBuffer2);
    PB_BlinkInitial(0);
    break;
  case 11:                                            // right flipper button
    if (EnterIni[ByteBuffer] == 57) {
      EnterIni[ByteBuffer] = 65;}
    else if (EnterIni[ByteBuffer] == 90) {
      EnterIni[ByteBuffer] = 32;}
    else if (EnterIni[ByteBuffer] == 32) {
      EnterIni[ByteBuffer] = 48;}
    else {
      EnterIni[ByteBuffer]++;}
    KillTimer(ByteBuffer2);
    PB_BlinkInitial(0);
    break;}}

void PB_BlinkInitial(byte State) {                    // blink actual character
  if (State) {
    *(DisplayUpper+20+4*ByteBuffer) = 0;              // show a blank
    *(DisplayUpper+21+4*ByteBuffer) = 0;
    PB_ClearChest();
    State = 0;}
  else {
    byte Buffer = 0;
    for (byte i=0; i<3; i++) {
      *(DisplayUpper+20+4*i) = DispPattern1[(EnterIni[i]-32)*2];
      *(DisplayUpper+21+4*i) = DispPattern1[(EnterIni[i]-32)*2+1];}// restore the characters
    if (EnterIni[ByteBuffer] == 32) {                 // It's a blank
      Buffer = 0;}
    else if (EnterIni[ByteBuffer] < 65) {             // It's a number
      Buffer = EnterIni[ByteBuffer] - 47;}
    else {                                            // It's a letter
      Buffer = EnterIni[ByteBuffer] - 54;}
    for (byte x=0; x<5; x++) {                        // for all chest rows
      byte Mask = 16;                                 // mask to access the stored lamps for this player
      for (byte y=0; y<5; y++) {                      // for all columns
        if (PB_Characters[Buffer*5+x] & Mask) {
          TurnOnLamp(28+x+8*y);}
        else {
          TurnOffLamp(28+x+8*y);}
        Mask = Mask>>1;}}
    State = 1;}
  ByteBuffer2 = ActivateTimer(100+State*2000, State, PB_BlinkInitial);}  // and come back

void PB_EnterInitials2(byte Dummy) {
  UNUSED(Dummy);
  PB_Congrats(0);
  if (ByteBuffer > 2) {
    ByteBuffer2 = HandleHighScores(Points[Player]);
    WriteUpper2(" HIGH   SCORE ");
    ScrollUpper(0);
    ActivateTimer(2000, 1, PB_EnterInitials3);}
  else {
    PB_BallEnd3(1);}}

void PB_EnterInitials3(byte Dummy) {
  UNUSED(Dummy);
  WriteUpper2("TABLE  POS    ");
  *(DisplayUpper2+28) = DispPattern1[32 + 2 * (ByteBuffer2+1)];
  *(DisplayUpper2+29) = DispPattern1[33 + 2 * (ByteBuffer2+1)];
  ScrollUpper(0);
  ReleaseSolenoid(11);
  ReleaseSolenoid(12);
  PB_LampSweepActive = 0;
  ActivateTimer(2000, 1, PB_BallEnd3);}

void PB_ResetHighScores(bool change) {                // delete the high scores file
  if (change) {                                       // if the start button has been pressed
    if (SDfound) {
      SD.remove(GameDefinition.HighScoresFileName);
      struct HighScores HScBuffer;                    // create new high score table
      HallOfFame = HScBuffer;                         // copy it to the hall of fame
      WriteLower(" SCORES DONE  ");}
    else {
      WriteLower(" SCORES NO SD ");}}
  else {
    WriteLower(" SCORES       ");}}

void PB_RulesEffect(byte State) {
  const byte Pattern[22] = {4,0,4,8,12,9,12,11,44,11,108,11,124,43,125,59,125,187,127,187,127,191};
  for (byte i=0; i<15; i++) {
    if (i == 7) {
      continue;}
    if (!(*(DisplayUpper+2+2*i)) && !(*(DisplayUpper+3+2*i))) {
      continue;}
    if (State < 11) {
      *(DisplayUpper+2+2*i) = *(DisplayUpper+2+2*i) | Pattern[2*State];
      *(DisplayUpper+3+2*i) = *(DisplayUpper+3+2*i) | Pattern[2*State+1];}
    else {
      *(DisplayUpper+2+2*i) = *(DisplayUpper+2+2*i) & (255 - Pattern[2*(State-11)]);
      *(DisplayUpper+3+2*i) = *(DisplayUpper+3+2*i) & (255 - Pattern[2*(State-11)+1]);}}
  if (State < 22) {
    ActivateTimer(30, State+1, PB_RulesEffect);}}

void PB_RuleLampEffects(byte State) {
  static byte Timer = 0;
  switch(State) {
  case 0:
    if (Timer) {
      KillTimer(Timer);}
    Timer = 0;
    PB_ClearChest();
    ReleaseSolenoid(7);
    ReleaseSolenoid(8);
    break;
  case 1:
    if (Timer) {
      return;}
    TurnOnLamp(60);
    /* no break */
  case 2:
    for (byte i=0; i<4;i++) {
      TurnOnLamp(28+8*i);
      TurnOffLamp(61+i);}
    Timer = ActivateTimer(200, 3, PB_RuleLampEffects);
    break;
  case 3:
    for (byte i=0; i<4;i++) {
      TurnOffLamp(28+8*i);
      TurnOnLamp(61+i);}
    Timer = ActivateTimer(200, 2, PB_RuleLampEffects);
    break;
  case 5:
    if (Timer) {
      return;}
    /* no break */
  case 6:
    ActivateSolenoid(0, 7);
    ActivateSolenoid(0, 8);
    Timer = ActivateTimer(300, 7, PB_RuleLampEffects);
    break;
  case 7:
    ReleaseSolenoid(7);
    ReleaseSolenoid(8);
    Timer = ActivateTimer(300, 6, PB_RuleLampEffects);
    break;
  case 10:
    if (Timer) {
      return;}
    TurnOnLamp(28);
    Timer = ActivateTimer(100, 11, PB_RuleLampEffects);
    break;
  case 36:
    Timer = 0;
    break;
  default:
    byte Lamp = State - 10;
    byte Lamp2 = Lamp % 5;
    Lamp = Lamp / 5;
    TurnOnLamp(28 + Lamp2 + Lamp * 8);
    Timer = ActivateTimer(100, State+1, PB_RuleLampEffects);
    break;}}

void PB_RulesDisplay(byte State) {
  static byte Timer = 0;
  switch(State) {
  case 0:
    PB_RuleLampEffects(0);
    if (Timer) {
      KillTimer(Timer);}
    Timer = 0;
    StopAllBlinkLamps();
    ReleaseSolenoid(12);
    ReleaseSolenoid(14);
    break;
  case 1:
    if (Timer) {
      return;}
    ActivateSolenoid(0, 14);
    ActivateSolenoid(0, 12);
    /* no break */
  case 3:
  case 5:
  case 7:
    WriteUpper("PINBOT RULES--");
    WriteLower("              ");
    PlaySound(50, "0_6f.snd");
    Timer = ActivateTimer(300, State+1, PB_RulesDisplay);
    break;
  case 9:
    WriteUpper("PINBOT RULES--");
    WriteLower("              ");
    PlaySound(50, "0_6f.snd");
    Timer = ActivateTimer(2000, State+1, PB_RulesDisplay);
    break;
  case 2:
  case 4:
  case 6:
  case 8:
  case 10:
    WriteUpper("              ");
    Timer = ActivateTimer(300, State+1, PB_RulesDisplay);
    break;
  case 11:
    WriteUpper("PLUNGER MAKES ");
    Timer = ActivateTimer(2500, State+1, PB_RulesDisplay);
    break;
  case 12:
    WriteUpper("              ");
    if (game_settings[PB_Multiballs]) {
      Timer = ActivateTimer(300, 150, PB_RulesDisplay);}
    else {
      Timer = ActivateTimer(300, State+1, PB_RulesDisplay);}
    break;
  case 13:
    WriteUpper("VORTEX   1X   ");
    Timer = ActivateTimer(300, State+1, PB_RulesDisplay);
    break;
  case 14:
    WriteUpper("VORTEX   2X   ");
    Timer = ActivateTimer(300, State+1, PB_RulesDisplay);
    break;
  case 15:
    WriteUpper("VORTEX   3X   ");
    Timer = ActivateTimer(300, State+1, PB_RulesDisplay);
    break;
  case 16:
    WriteUpper("VORTEX   4X   ");
    Timer = ActivateTimer(300, State+1, PB_RulesDisplay);
    break;
  case 17:
    WriteUpper("VORTEX   5X   ");
    Timer = ActivateTimer(300, State+1, PB_RulesDisplay);
    break;
  case 18:
    WriteUpper("VORTEX   6X   ");
    Timer = ActivateTimer(300, State+1, PB_RulesDisplay);
    break;
  case 19:
    WriteUpper("VORTEX   7X   ");
    Timer = ActivateTimer(300, State+1, PB_RulesDisplay);
    break;
  case 20:
    WriteUpper("VORTEX   8X   ");
    Timer = ActivateTimer(300, State+1, PB_RulesDisplay);
    break;
  case 21:
    WriteUpper("VORTEX   9X   ");
    Timer = ActivateTimer(300, State+1, PB_RulesDisplay);
    break;
  case 22:
    WriteUpper("VORTEX   10X  ");
    *(DisplayUpper+13*2+1) = 64 | *(DisplayUpper+13*2+1); // add a dot in column 12
    Timer = ActivateTimer(2700, State+1, PB_RulesDisplay);
    break;
  case 23:
    Timer = ActivateTimer(800, State+1, PB_RulesDisplay);
    PB_RulesEffect(0);
    break;
  case 24:
  case 26:
  case 28:
  case 30:
  case 32:
    WriteUpper("        WHEN  ");
    DisplayScore(1, 1000000);
    Timer = ActivateTimer(300, State+1, PB_RulesDisplay);
    break;
  case 25:
  case 27:
  case 29:
  case 31:
    WriteUpper("        WHEN  ");
    Timer = ActivateTimer(300, State+1, PB_RulesDisplay);
    break;
  case 33:
    WriteUpper("VORTEX AT 10X ");
    *(DisplayUpper+14*2+1) = 64 | *(DisplayUpper+14*2+1); // add a dot in column 13
    Timer = ActivateTimer(2700, State+1, PB_RulesDisplay);
    break;
  case 34:
    Timer = ActivateTimer(800, State+1, PB_RulesDisplay);
    PB_RulesEffect(0);
    break;
  case 35:
    WriteUpper("ADVANCEPLANETS");
    for (byte i=19; i<28; i++) {
      AddBlinkLamp(i, 100);}
    Timer = ActivateTimer(2500, State+1, PB_RulesDisplay);
    break;
  case 36:
    WriteUpper("  BY 3  BANK  ");
    for (byte i=41; i<44; i++) {
      AddBlinkLamp(i, 100);}
    for (byte i=19; i<28; i++) {
      RemoveBlinkLamp(i);
      TurnOnLamp(i);}
    Timer = ActivateTimer(2500, State+1, PB_RulesDisplay);
    break;
  case 37:
    WriteUpper(" OR BY TARGET ");
    *(DisplayUpper+14*2+1) = 64 | *(DisplayUpper+14*2+1); // add a dot in column 13
    AddBlinkLamp(18, 100);
    for (byte i=41; i<44; i++) {
      RemoveBlinkLamp(i);
      TurnOnLamp(i);}
    Timer = ActivateTimer(2200, State+1, PB_RulesDisplay);
    break;
  case 38:
    Timer = ActivateTimer(800, State+1, PB_RulesDisplay);
    PB_RulesEffect(0);
    break;
  case 39:
    {char Planet[15] = " REACH        ";
    for (byte i=7; i<15; i++) {
      Planet[i] = PB_PlanetTxt[game_settings[PB_ReachPlanet]][i];}
    WriteUpper((char*) Planet);}
    AddBlinkLamp(19+game_settings[PB_ReachPlanet], 100);
    RemoveBlinkLamp(18);
    TurnOnLamp(18);
    Timer = ActivateTimer(2200, State+1, PB_RulesDisplay);
    break;
  case 40:
    WriteUpper("  FOR  SPECIAL");
    *(DisplayUpper+15*2+1) = 64 | *(DisplayUpper+15*2+1); // add a dot in column 14
    Timer = ActivateTimer(2200, State+1, PB_RulesDisplay);
    break;
  case 41:
    Timer = ActivateTimer(800, State+1, PB_RulesDisplay);
    RemoveBlinkLamp(19+game_settings[PB_ReachPlanet]);
    for (byte i=19; i<28; i++) {
      TurnOffLamp(i);}
    PB_RulesEffect(0);
    break;
  case 42:
    WriteUpper(" REACH THE SUN");
    Timer = ActivateTimer(300, State+1, PB_RulesDisplay);
    break;
  case 43:
  case 44:
  case 45:
  case 46:
  case 47:
  case 48:
  case 49:
  case 50:
  case 51:
    TurnOnLamp(State-24);
    Timer = ActivateTimer(300, State+1, PB_RulesDisplay);
    break;
  case 52:
    ActivateSolenoid(150, 8);
    Timer = ActivateTimer(300, State+1, PB_RulesDisplay);
    break;
  case 53:
    WriteUpper("TO LITESPECIAL");
    *(DisplayUpper+15*2+1) = 64 | *(DisplayUpper+15*2+1); // add a dot in column 14
    AddBlinkLamp(51, 100);
    Timer = ActivateTimer(2200, State+1, PB_RulesDisplay);
    break;
  case 54:
    Timer = ActivateTimer(800, State+1, PB_RulesDisplay);
    PB_RulesEffect(0);
    break;
  case 55:
  case 56:
  case 57:
  case 58:
  case 59:
  case 60:
  case 61:
  case 62:
    WriteUpper("  JET  BUMPERS");
    RemoveBlinkLamp(51);
    for (byte i=19;i<28;i++) {
      TurnOffLamp(i);}
    for (byte i=41; i<44; i++) {
      TurnOffLamp(i);}
    TurnOffLamp(18);
    ActivateSolenoid(150, 6);
    Timer = ActivateTimer(300, State+1, PB_RulesDisplay);
    break;
  case 63:
  case 64:
  case 65:
  case 66:
  case 67:
  case 68:
  case 69:
  case 70:
    WriteUpper("  ADD   ENERGY");
    *(DisplayUpper+15*2+1) = 64 | *(DisplayUpper+15*2+1); // add a dot in column 14
    ActivateSolenoid(150, 6);
    Timer = ActivateTimer(300, State+1, PB_RulesDisplay);
    break;
  case 71:
    Timer = ActivateTimer(800, State+1, PB_RulesDisplay);
    PB_RulesEffect(0);
    break;
  case 72:
    WriteUpper(" RAISE   RAMP ");
    TurnOffLamp(18);
    for (byte i=41; i<44; i++) {
      AddBlinkLamp(i, 100);}
    Timer = ActivateTimer(2500, State+1, PB_RulesDisplay);
    break;
  case 73:
    WriteUpper("   TO    LITE ");
    Timer = ActivateTimer(2500, State+1, PB_RulesDisplay);
    break;
  case 74:
    WriteUpper(" SCORE  ENERGY");
    *(DisplayUpper+15*2+1) = 64 | *(DisplayUpper+15*2+1); // add a dot in column 14
    AddBlinkLamp(34, 100);
    for (byte i=41; i<44; i++) {
      RemoveBlinkLamp(i);}
    Timer = ActivateTimer(2700, State+1, PB_RulesDisplay);
    break;
  case 75:
    Timer = ActivateTimer(800, State+1, PB_RulesDisplay);
    PB_RulesEffect(0);
    break;
  case 76:
    WriteUpper("  RAMP  GIVES ");
    AddBlinkLamp(35, 100);
    RemoveBlinkLamp(34);
    Timer = ActivateTimer(2500, State+1, PB_RulesDisplay);
    break;
  case 77:
    WriteUpper(" BONUS  MULT  ");
    *(DisplayUpper+13*2+1) = 64 | *(DisplayUpper+13*2+1); // add a dot in column 12
    for (byte i=9; i<13; i++) {
      AddBlinkLamp(i, 100);}
    RemoveBlinkLamp(35);
    Timer = ActivateTimer(2700, State+1, PB_RulesDisplay);
    break;
  case 78:
    Timer = ActivateTimer(800, State+1, PB_RulesDisplay);
    PB_RulesEffect(0);
    break;
  case 79:
    WriteUpper(" HIT   5 BANKS");
    for (byte i=9; i<13; i++) {
      RemoveBlinkLamp(i);}
    PB_RuleLampEffects(1);
    Timer = ActivateTimer(2500, State+1, PB_RulesDisplay);
    break;
  case 80:
    WriteUpper("  TO          ");
    Timer = ActivateTimer(2500, State+1, PB_RulesDisplay);
    break;
  case 81:
    WriteUpper(" OPEN   VISOR ");
    *(DisplayUpper+14*2+1) = 64 | *(DisplayUpper+14*2+1); // add a dot in column 13
    PB_RuleLampEffects(0);
    PB_RuleLampEffects(10);
    Timer = ActivateTimer(2500, State+1, PB_RulesDisplay);
    break;
  case 82:
    ActivateSolenoid(0, 10);
    ActivateSolenoid(0, 18);
    Timer = ActivateTimer(2000, 0, PB_OpenVisor);
    ActivateSolenoid(0, 13);
    Timer = ActivateTimer(2700, State+1, PB_RulesDisplay);
    break;
  case 83:
    Timer = ActivateTimer(800, State+1, PB_RulesDisplay);
    PB_RulesEffect(0);
    break;
  case 84:
    WriteUpper("FILLING  CHEST");
    PB_ClearChest();
    PB_RuleLampEffects(10);
    Timer = ActivateTimer(3000, State+1, PB_RulesDisplay);
    break;
  case 85:
    WriteUpper(" AGAIN        ");
    Timer = ActivateTimer(2500, State+1, PB_RulesDisplay);
    break;
  case 86:
    WriteUpper(" LITES EX BALL");
    AddBlinkLamp(49, 100);
    AddBlinkLamp(50, 100);
    AddBlinkLamp(57, 100);
    AddBlinkLamp(58, 100);
    *(DisplayUpper+10*2+1) = 64 | *(DisplayUpper+10*2+1); // add a dot in column 9
    *(DisplayUpper+15*2+1) = 64 | *(DisplayUpper+15*2+1); // add a dot in column 14
    Timer = ActivateTimer(2200, State+1, PB_RulesDisplay);
    break;
  case 87:
    Timer = ActivateTimer(800, State+1, PB_RulesDisplay);
    PB_RulesEffect(0);
    break;
  case 88:
    WriteUpper(" LOCK   BALLS ");
    RemoveBlinkLamp(49);
    RemoveBlinkLamp(50);
    RemoveBlinkLamp(57);
    RemoveBlinkLamp(58);
    PB_EyeBlink(1);
    if (game_settings[PB_Multiballs]) {
      Timer = ActivateTimer(2500, 160, PB_RulesDisplay);}
    else {
      Timer = ActivateTimer(2500, State+1, PB_RulesDisplay);}
    break;
  case 89:
    WriteUpper("  FOR         ");
    Timer = ActivateTimer(2500, State+1, PB_RulesDisplay);
    break;
  case 90:
    WriteUpper("DOUBLE  SCORE ");
    *(DisplayUpper+14*2+1) = 64 | *(DisplayUpper+14*2+1); // add a dot in column 13
    Timer = ActivateTimer(2700, State+1, PB_RulesDisplay);
    break;
  case 91:
    Timer = ActivateTimer(800, State+1, PB_RulesDisplay);
    PB_RulesEffect(0);
    break;
  case 92:
    WriteUpper(" DURING       ");
    PB_EyeBlink(0);
    ActivateSolenoid(0, 10);
    ActivateSolenoid(0, 18);
    Timer = ActivateTimer(2500, State+1, PB_RulesDisplay);
    break;
  case 93:
    WriteUpper(" MULTI  BALL  ");
    Timer = ActivateTimer(2500, State+1, PB_RulesDisplay);
    break;
  case 94:
    WriteUpper(" LOCK  1 BALL ");
    PB_EyeFlash(1);
    Timer = ActivateTimer(2500, State+1, PB_RulesDisplay);
    break;
  case 95:
    WriteUpper("   TO   START ");
    Timer = ActivateTimer(2500, State+1, PB_RulesDisplay);
    break;
  case 96:
    WriteUpper(" SOLAR ECLIPSE");
    *(DisplayUpper+15*2+1) = 64 | *(DisplayUpper+15*2+1); // add a dot in column 14
    PB_EyeFlash(0);
    PB_EyeFlash(1);
    AddBlinkLamp(35, 100);
    Timer = ActivateTimer(2700, State+1, PB_RulesDisplay);
    break;
  case 97:
    Timer = ActivateTimer(800, State+1, PB_RulesDisplay);
    PB_RulesEffect(0);
    break;
  case 98:
    WriteUpper(" GO UP   RAMP ");
    PB_EyeFlash(0);
    Timer = ActivateTimer(2500, State+1, PB_RulesDisplay);
    break;
  case 99:
    WriteUpper("   TO  COLLECT");
    Timer = ActivateTimer(2500, State+1, PB_RulesDisplay);
    break;
  case 100:
    WriteUpper(" SOLAR  SCORE ");
    WriteLower("   OF         ");
    DisplayScore(4, 100000);
    RemoveBlinkLamp(35);
    Timer = ActivateTimer(2000, 0, PB_CloseVisor);
    ActivateSolenoid(0, 13);
    Timer = ActivateTimer(5000, State+1, PB_RulesDisplay);
    break;
  case 101:
    Timer = 0;
    ReleaseSolenoid(12);
    ReleaseSolenoid(14);
    PB_AttractMode();
    break;
  case 150:
    DisplayScore(2, 100000);
    *(DisplayUpper+15*2+1) = 64 | *(DisplayUpper+15*2+1); // add a dot in column 14
    Timer = ActivateTimer(2700, State+1, PB_RulesDisplay);
    break;
  case 151:
    Timer = ActivateTimer(800, 35, PB_RulesDisplay);
    PB_RulesEffect(0);
    break;
  case 160:
    WriteUpper("   TO   LITE  ");
    Timer = ActivateTimer(2500, State+1, PB_RulesDisplay);
    break;
  case 161:
    WriteUpper(" THIRD  LOCK  ");
    *(DisplayUpper+13*2+1) = 64 | *(DisplayUpper+13*2+1); // add a dot in column 12
    PB_EyeBlink(0);
    PB_HandleEjectHole(15);
    Timer = ActivateTimer(2700, State+1, PB_RulesDisplay);
    break;
  case 162:
    Timer = ActivateTimer(800, State+1, PB_RulesDisplay);
    PB_RulesEffect(0);
    break;
  case 163:
    WriteUpper("  LOCK  BALL  ");
    Timer = ActivateTimer(2500, State+1, PB_RulesDisplay);
    break;
  case 164:
    WriteUpper("  TO    START ");
    Timer = ActivateTimer(2500, State+1, PB_RulesDisplay);
    break;
  case 165:
    WriteUpper(" MULTI  BALL  ");
    *(DisplayUpper+13*2+1) = 64 | *(DisplayUpper+13*2+1); // add a dot in column 12
    Timer = ActivateTimer(2700, State+1, PB_RulesDisplay);
    break;
  case 166:
    Timer = ActivateTimer(800, State+1, PB_RulesDisplay);
    PB_RulesEffect(0);
    break;
  case 167:
    WriteUpper(" DURING       ");
    PB_ClearChest();
    PB_HandleEjectHole(16);
    Timer = ActivateTimer(2500, State+1, PB_RulesDisplay);
    break;
  case 168:
    WriteUpper(" MULTI  BALL  ");
    Timer = ActivateTimer(2500, State+1, PB_RulesDisplay);
    break;
  case 169:
    WriteUpper(" SHOOT RAMP   ");
    AddBlinkLamp(35, 100);
    Timer = ActivateTimer(2500, State+1, PB_RulesDisplay);
    break;
  case 170:
    WriteUpper("  FOR         ");
    Timer = ActivateTimer(2500, State+1, PB_RulesDisplay);
    break;
  case 171:
  case 172:
  case 173:
  case 174:
  case 175:
    WriteUpper("JACKPOT       ");
    DisplayScore(2, 200000 * (State - 170));
    Timer = ActivateTimer(500, State+1, PB_RulesDisplay);
    break;
  case 176:
  case 178:
  case 180:
  case 182:
    WriteUpper("JACKPOT       ");
    Timer = ActivateTimer(500, State+1, PB_RulesDisplay);
    break;
  case 177:
  case 179:
  case 181:
    WriteUpper("JACKPOT       ");
    DisplayScore(2, 1000000);
    Timer = ActivateTimer(500, State+1, PB_RulesDisplay);
    break;
  case 183:
    WriteUpper("JACKPOT       ");
    RemoveBlinkLamp(35);
    DisplayScore(2, 1000000);
    *(DisplayUpper+15*2+1) = 64 | *(DisplayUpper+15*2+1); // add a dot in column 14
    Timer = ActivateTimer(2700, State+1, PB_RulesDisplay);
    break;
  case 184:
    Timer = ActivateTimer(800, State+1, PB_RulesDisplay);
    PB_RulesEffect(0);
    break;
  case 185:
    WriteUpper(" LOCKS        ");
    PB_EyeFlash(1);
    PB_HandleEjectHole(15);
    Timer = ActivateTimer(2500, State+1, PB_RulesDisplay);
    break;
  case 186:
    WriteUpper("  HOLD  BALLS ");
    Timer = ActivateTimer(2500, State+1, PB_RulesDisplay);
    break;
  case 187:
    {char Time[15] = "  FOR       S ";
    Time[11] = 48 + game_settings[PB_MballHoldTime] % 10;
    if (game_settings[PB_MballHoldTime] > 9) {
      Time[10] = 48 + game_settings[PB_MballHoldTime] / 10;}
    WriteUpper((char*) Time);
    *(DisplayUpper+14*2+1) = 64 | *(DisplayUpper+14*2+1);} // add a dot in column 13
    Timer = ActivateTimer(2700, State+1, PB_RulesDisplay);
    break;
  case 188:
    Timer = ActivateTimer(800, State+1, PB_RulesDisplay);
    PB_EyeFlash(0);
    PB_HandleEjectHole(16);
    PB_RulesEffect(0);
    break;
  case 189:
    WriteUpper(" IF ONE BALL  ");
    Timer = ActivateTimer(2500, State+1, PB_RulesDisplay);
    break;
  case 190:
    WriteUpper(" DRAINS       ");
    Timer = ActivateTimer(2500, State+1, PB_RulesDisplay);
    break;
  case 191:
    WriteUpper("RE-LOCK2 BALLS");
    PB_EyeBlink(1);
    Timer = ActivateTimer(2500, State+1, PB_RulesDisplay);
    break;
  case 192:
    WriteUpper("  TO   RE-LITE");
    Timer = ActivateTimer(2500, State+1, PB_RulesDisplay);
    break;
  case 193:
    WriteUpper(" THIRD  LOCK  ");
    *(DisplayUpper+13*2+1) = 64 | *(DisplayUpper+13*2+1); // add a dot in column 12
    PB_EyeBlink(0);
    PB_HandleEjectHole(15);
    Timer = ActivateTimer(2700, State+1, PB_RulesDisplay);
    break;
  case 194:
    PB_RulesEffect(0);
    Timer = ActivateTimer(2000, State+1, PB_RulesDisplay);
    break;
  case 195:
    Timer = 0;
    PB_HandleEjectHole(16);
    ReleaseSolenoid(12);
    ReleaseSolenoid(14);
    PB_AttractMode();
    break;}}


void PB_Testmode(byte Select) {
  Switch_Pressed = PB_Testmode;
  switch(AppByte) {                                   // which testmode?
  case 0:                                             // display test
    switch(Select) {                                  // switch events
    case 0:                                           // init (not triggered by switch)
      *(DisplayLower) = 0;                            // clear credit display
      *(DisplayLower+16) = 0;
      *(DisplayUpper) = 0;
      *(DisplayUpper+16) = 0;
      WriteUpper("DISPLAY TEST  ");
      WriteLower("              ");
      AppByte2 = 0;
      break;
    case 3:                                           // credit button
      WriteUpper("0000000000000000");
      WriteLower("0000000000000000");
      AppByte2 = ActivateTimer(1000, 32, PB_DisplayCycle);
      break;
    case 72:                                          // advance button
      if (AppByte2) {
        KillTimer(AppByte2);
        AppByte2 = 0;}
      else {
        AppByte++;}
      PB_Testmode(0);}
    break;
    case 1:                                           // switch edges test
      switch(Select) {                                // switch events
      case 0:                                         // init (not triggered by switch)
        AppByte2 = 0;
        WriteUpper(" SWITCHEDGES  ");
        WriteLower("              ");
        break;
      case 72:                                        // advance button
        if (AppByte2) {
          AppByte2 = 0;}
        else {
          AppByte++;}
        PB_Testmode(0);
        break;
      case 3:                                         // credit button
        if (!AppByte2) {
          WriteUpper(" LATESTEDGES  ");
          AppByte2 = 1;
          break;} // @suppress("No break at end of case")
      default:                                        // all other switches
        for (byte i=1; i<24; i++) {                   // move all characters in the lower display row 4 chars to the left
          DisplayLower[i] = DisplayLower[i+8];}
        *(DisplayLower+30) = DispPattern2[32 + 2 * (Select % 10)]; // and insert the switch number to the right of the row
        *(DisplayLower+31) = DispPattern2[33 + 2 * (Select % 10)];
        *(DisplayLower+28) = DispPattern2[32 + 2 * (Select - (Select % 10)) / 10];
        *(DisplayLower+29) = DispPattern2[33 + 2 * (Select - (Select % 10)) / 10];}
      break;
      case 2:                                         // solenoid test
        switch(Select) {                              // switch events
        case 0:                                       // init (not triggered by switch)
          WriteUpper("  COIL  TEST  ");
          WriteLower("              ");
          AppByte2 = 0;
          break;
        case 3:
          WriteUpper(" FIRINGCOIL NO");
          AppBool = false;
          AppByte2 = ActivateTimer(1000, 1, PB_FireSolenoids);
          break;
        case 72:
          if (AppByte2) {
            KillTimer(AppByte2);
            AppByte2 = 0;}
          else {
            AppByte++;}
          PB_Testmode(0);}
        break;
        case 3:                                       // single lamp test
          switch(Select) {                            // switch events
          case 0:                                     // init (not triggered by switch)
            WriteUpper(" SINGLE LAMP  ");
            WriteLower("              ");
            AppByte2 = 0;
            for (byte i=0; i<(LampMax+1); i++){       // erase lamp matrix
              TurnOffLamp(i);}
            LampPattern = LampColumns;                // and show it
            break;
          case 3:
            WriteUpper(" ACTUAL LAMP  ");
            AppByte2 = ActivateTimer(1000, 1, PB_ShowLamp);
            break;
          case 72:
            LampPattern = NoLamps;
            if (AppByte2) {
              KillTimer(AppByte2);
              AppByte2 = 0;}
            else {
              AppByte++;}
            PB_Testmode(0);}
          break;
          case 4:                                     // all lamps test
            switch(Select) {                          // switch events
            case 0:                                   // init (not triggered by switch)
              WriteUpper("  ALL   LAMPS ");
              WriteLower("              ");
              AppByte2 = 0;
              break;
            case 3:
              WriteUpper("FLASHNG LAMPS ");
              AppByte2 = ActivateTimer(1000, 1, PB_ShowAllLamps);
              break;
            case 72:
              LampPattern = NoLamps;
              if (AppByte2) {
                KillTimer(AppByte2);
                AppByte2 = 0;}
              else {
                AppByte++;}
              PB_Testmode(0);}
            break;
            case 5:                                   // all music test
              switch(Select) {                        // switch events
              case 0:                                 // init (not triggered by switch)
                WriteUpper(" MUSIC  TEST  ");
                WriteLower("              ");
                AppByte2 = 0;
                break;
              case 3:
                if (!AppByte2) {                      // first sound?
                  WriteUpper("PLAYING MUSIC ");
                  *(DisplayLower+30) = DispPattern2[32 + 2 * ((AppByte2+1) % 10)]; // show the actual sound number
                  *(DisplayLower+31) = DispPattern2[33 + 2 * ((AppByte2+1) % 10)];
                  *(DisplayLower+28) = DispPattern2[32 + 2 * ((AppByte2+1) - ((AppByte2+1) % 10)) / 10];
                  *(DisplayLower+29) = DispPattern2[33 + 2 * ((AppByte2+1) - ((AppByte2+1) % 10)) / 10];
                  AfterMusic = PB_NextTestSound;
                  PlayMusic(50, (char*) PB_TestSounds[AppByte2]);
                  AppByte2++;}                        // prepare for next sound
                else {                                // not the first sound
                  PB_NextTestSound(0);}
                break;
              case 72:
                AfterMusic = 0;
                StopPlayingMusic();
                if (AppByte2) {
                  AppByte2 = 0;}
                else {
                  AppByte++;}
                PB_Testmode(0);}
              break;
              case 6:                                 // visor test
                switch(Select) {                      // switch events
                case 0:                               // init (not triggered by switch)
                  WriteUpper(" VISOR  TEST  ");
                  WriteLower("              ");
                  AppByte2 = 0;
                  AppBool = false;
                  break;
                case 3:
                  AppByte2 = 1;
                  if (AppBool) {
                    if (QuerySwitch(46)) {
                      AppBool = false;
                      PB_Testmode(3);}
                    else {
                      WriteUpper("CLOSING VISOR ");
                      ActivateSolenoid(0, 13);}}
                  else {
                    if (QuerySwitch(47)) {
                      AppBool = true;
                      PB_Testmode(3);}
                    else {
                      WriteUpper("OPENING VISOR ");
                      ActivateSolenoid(0, 13);}}
                  break;
                case 46:
                  if (AppBool) {
                    ReleaseSolenoid(13);
                    AppBool = false;
                    WriteUpper(" VISOR CLOSED ");}
                  break;
                case 47:
                  if (!AppBool) {
                    ReleaseSolenoid(13);
                    AppBool = true;
                    WriteUpper(" VISOR  OPEN  ");}
                  break;
                case 72:
                  ReleaseSolenoid(13);
                  if (AppByte2) {
                    AppByte2 = 0;}
                  else {
                    // AppByte++;}
                    GameDefinition.AttractMode();
                    return;}
                  PB_Testmode(0);
                  break;
                }}}

void PB_ShowLamp(byte CurrentLamp) {                  // cycle all solenoids
  if (QuerySwitch(73)) {                              // Up/Down switch pressed?
    *(DisplayLower+30) = DispPattern2[32 + 2 * (CurrentLamp % 10)]; // and show the actual solenoid number
    *(DisplayLower+31) = DispPattern2[33 + 2 * (CurrentLamp % 10)];
    *(DisplayLower+28) = DispPattern2[32 + 2 * (CurrentLamp - (CurrentLamp % 10)) / 10];
    *(DisplayLower+29) = DispPattern2[33 + 2 * (CurrentLamp - (CurrentLamp % 10)) / 10];
    TurnOnLamp(CurrentLamp);                          // turn on lamp
    if (CurrentLamp > 1) {                            // and turn off the previous one
      TurnOffLamp(CurrentLamp-1);}
    else {
      TurnOffLamp(LampMax);}
    CurrentLamp++;                                    // increase the lamp counter
    if (CurrentLamp == LampMax+1) {                   // maximum reached?
      CurrentLamp = 1;}}                              // then start again
  AppByte2 = ActivateTimer(1000, CurrentLamp, PB_ShowLamp);} // come back in one second

void PB_ShowAllLamps(byte State) {                    // Flash all lamps
  if (State) {                                        // if all lamps are on
    LampPattern = NoLamps;                            // turn them off
    State = 0;}
  else {                                              // or the other way around
    LampPattern = AllLamps;
    State = 1;}
  AppByte2 = ActivateTimer(500, State, PB_ShowAllLamps);}  // come back in 500ms

void PB_FireSolenoids(byte Solenoid) {                // cycle all solenoids
  if (AppBool) {                                      // if C bank solenoid
    ActC_BankSol(Solenoid);
    *(DisplayLower+30) = DispPattern2[('C'-32)*2];    // show the C
    *(DisplayLower+31) = DispPattern2[('C'-32)*2+1];
    if (QuerySwitch(73)) {                            // Up/Down switch pressed?
      AppBool = false;
      Solenoid++;}}
  else {                                              // if A bank solenoid
    *(DisplayLower+28) = DispPattern2[32 + 2 * (Solenoid % 10)]; // show the actual solenoid number
    *(DisplayLower+29) = DispPattern2[33 + 2 * (Solenoid % 10)];
    *(DisplayLower+26) = DispPattern2[32 + 2 * (Solenoid - (Solenoid % 10)) / 10];
    *(DisplayLower+27) = DispPattern2[33 + 2 * (Solenoid - (Solenoid % 10)) / 10];

    if (Solenoid == 11 || Solenoid == 12 || Solenoid == 13 || Solenoid == 14 || Solenoid == 9 || Solenoid == 10 || Solenoid == 18) {  // is it a relay or a #1251 flasher?
      ActivateSolenoid(999, Solenoid);}               // then the duration must be specified
    else {
      ActivateSolenoid(0, Solenoid);}                 // activate the solenoid
    if (Solenoid < 9) {
      *(DisplayLower+30) = DispPattern2[('A'-32)*2];  // show the A
      *(DisplayLower+31) = DispPattern2[('A'-32)*2+1];
      if (QuerySwitch(73)) {                          // Up/Down switch pressed?
        AppBool = true;}}
    else {
      *(DisplayLower+30) = DispPattern2[(' '-32)*2];  // delete the C
      *(DisplayLower+31) = DispPattern2[(' '-32)*2+1];
      if (QuerySwitch(73)) {                          // Up/Down switch pressed?
        Solenoid++;                                   // increase the solenoid counter
        if (Solenoid > 22) {                          // maximum reached?
          Solenoid = 1;}}}}                           // then start again
  AppByte2 = ActivateTimer(1000, Solenoid, PB_FireSolenoids);}   // come back in one second

void PB_DisplayCycle(byte CharNo) {                   // Display cycle test
  if (QuerySwitch(73)) {                              // cycle only if Up/Down switch is not pressed
    if (CharNo == 116) {                              // if the last character is reached
      CharNo = 32;}                                   // start from the beginning
    else {
      if (CharNo == 50) {                             // reached the gap between numbers and characters?
        CharNo = 66;}
      else {
        CharNo = CharNo+2;}}                          // otherwise show next character
    for (byte i=0; i<16; i++) {                       // use for all alpha digits
      if ((i==0) || (i==8)) {
        DisplayUpper[2*i] = LeftCredit[CharNo];
        DisplayUpper[2*i+1] = LeftCredit[CharNo+1];
        DisplayLower[2*i] = RightCredit[CharNo];
        DisplayLower[2*i+1] = RightCredit[CharNo+1];}
      else {
        DisplayUpper[2*i] = DispPattern1[CharNo];
        DisplayUpper[2*i+1] = DispPattern1[CharNo+1];
        DisplayLower[2*i] = DispPattern2[CharNo];
        DisplayLower[2*i+1] = DispPattern2[CharNo+1];}}}
  AppByte2 = ActivateTimer(500, CharNo, PB_DisplayCycle);}   // restart timer

void PB_NextTestSound(byte Dummy) {
  UNUSED(Dummy);
  *(DisplayLower+30) = DispPattern2[32 + 2 * ((AppByte2+1) % 10)]; // show the actual sound number
  *(DisplayLower+31) = DispPattern2[33 + 2 * ((AppByte2+1) % 10)];
  *(DisplayLower+28) = DispPattern2[32 + 2 * ((AppByte2+1) - ((AppByte2+1) % 10)) / 10];
  *(DisplayLower+29) = DispPattern2[33 + 2 * ((AppByte2+1) - ((AppByte2+1) % 10)) / 10];
  PlayMusic(50, (char*) PB_TestSounds[AppByte2]);
  if (QuerySwitch(73)) {                              // Up/Down switch not pressed?
    AppByte2++;}                                      // proceed to next sound
  if (!PB_TestSounds[AppByte2][0]) {
    AppByte2 = 0;}}
